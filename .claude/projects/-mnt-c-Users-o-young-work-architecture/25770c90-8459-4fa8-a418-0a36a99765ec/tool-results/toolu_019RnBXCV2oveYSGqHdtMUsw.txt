The file /mnt/c/Users/o.young/work/architecture/bounded_context/product_catalog.cml has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
     1→/*
     2→ * ProductCatalogService - Bounded Context Definition
     3→ * ===================================================
     4→ *
     5→ * Facade and Anti-Corruption Layer for product catalog and pricing data.
     6→ * Bridges D365 Commerce (Azure back-office) with customer-facing digital experiences (AWS).
     7→ *
     8→ * See product_catalog.adoc for comprehensive architecture documentation and decision log.
     9→ */
    10→
    11→import "../domains/product_catalog.cml"
    12→
    13→BoundedContext ProductCatalogService implements ProductCatalogDomain {
    14→
    15→    type = APPLICATION
    16→
    17→    // Strategic DDD Classification: SUPPORTING_DOMAIN
    18→    // Enables product discovery and pricing across channels but is not a primary competitive differentiator.
    19→    // D365 Commerce owns the authoritative product catalog; this service translates and caches.
    20→    strategicClassification = "SUPPORTING_DOMAIN"
    21→
    22→    domainVisionStatement = "Facade and Anti-Corruption Layer that translates D365 Commerce product and pricing data into AWS-native APIs for customer-facing applications. Provides stable API contract in OTR's ubiquitous language."
    23→
    24→    responsibilities = "Cached pricing data for fast query access",
    25→                      "Translation from D365 Commerce model to OTR domain language (ACL)",
    26→                      "REST API for external consumers (DMB, mobile, web)",
    27→                      "ETL pipeline from D365 Commerce S3 exports",
    28→                      "Data validation and quality monitoring",
    29→                      "Event publishing for pricing changes (future-proofing)"
    30→
    31→    implementationTechnology = "AWS (S3, Glue/Lambda, RDS PostgreSQL, API Gateway, ECS Fargate), OAuth 2.0, CloudWatch"
    32→
    33→    // ========================================================================
    34→    // SECTION 1: CORE AGGREGATES
    35→    // ========================================================================
    36→    // ProductPrice is the ONLY aggregate.
    37→    // It represents cached pricing data from D365 Commerce for fast API queries.
    38→    // D365 Commerce is the authoritative source; ProductPrice is eventually consistent.
    39→    // ========================================================================
    40→
    41→    // 1.1 ProductPrice Aggregate
    42→    // ---------------------------
    43→    // Cached representation of product pricing from D365 Commerce.
    44→    // Updated hourly via ETL pipeline from S3 exports.
    45→    // Stored in RDS PostgreSQL for fast query access.
    46→    //
    47→    // Invariants:
    48→    // - Price amount must be greater than zero
    49→    // - Each product must have at least one price group
    50→    // - Effective date ranges cannot overlap for the same product/price group combination
    51→    // - Store IDs must exist in the store master data
    52→    //
    53→    // Lifecycle:
    54→    // 1. Created/updated via hourly ETL pipeline from D365 Commerce export
    55→    // 2. Validated against data contract schema
    56→    // 3. Stored in RDS PostgreSQL for fast query access
    57→    // 4. Queried via REST API by external consumers
    58→    // 5. Eventually consistent (max 1 hour lag from D365 Commerce)
    59→    Aggregate ProductPrice {
    60→        Entity Product {
    61→            aggregateRoot
    62→
    63→            - ProductId productId
    64→            - String productName
    65→            - ProductCategory category
    66→            - DateTime lastUpdated
    67→        }
    68→
    69→        Entity Price {
    70→            - PriceId id
    71→            - ProductId productId            // Reference to Product aggregate root
    72→            - PriceGroupId priceGroupId
    73→            - Money amount                   // Invariant: must be > 0
    74→            - Date effectiveFrom
    75→            - Date effectiveTo
    76→            - DateTime lastUpdated
    77→        }
    78→
    79→        Entity PriceGroup {
    80→            - PriceGroupId priceGroupId
    81→            - String priceGroupName
    82→            - String regionCode
    83→            - List<StoreAssignment> storeAssignments
    84→            - DateTime lastUpdated
    85→        }
    86→
    87→        ValueObject StoreAssignment {
    88→            - StoreId storeId
    89→            - Date effectiveFrom
    90→        }
    91→
    92→        ValueObject ProductId {
    93→            - String id                      // D365 Commerce product identifier
    94→        }
    95→
    96→        ValueObject PriceId {
    97→            - Long id                        // Database-generated identifier
    98→        }
    99→
   100→        ValueObject PriceGroupId {
   101→            - String id                      // D365 Commerce price group identifier (e.g., "POS-AU-NAT")
   102→        }
   103→
   104→        ValueObject StoreId {
   105→            - int id                         // D365 Commerce store number
   106→        }
   107→
   108→        ValueObject ProductCategory {
   109→            - String code
   110→            - String name
   111→        }
   112→
   113→        ValueObject Money {
   114→            - Decimal amount
   115→            - String currency                // AUD
   116→        }
   117→
   118→        ValueObject Date {
   119→            - String isoDate                 // ISO 8601 date format (YYYY-MM-DD)
   120→        }
   121→    }
   122→
   123→    // ========================================================================
   124→    // SECTION 2: APPLICATION SERVICES
   125→    // ========================================================================
   126→
   127→    // 2.1 PricingQueryService
   128→    // ------------------------
   129→    // Exposes REST API for external consumers to query pricing data.
   130→    // Returns data from RDS PostgreSQL cache (eventually consistent).
   131→    Service PricingQueryService {
   132→        // Get pricing data for all products or filtered by query parameters
   133→        @PricingResponse getPricing(
   134→            @ProductId productId,
   135→            @StoreId storeId,
   136→            @PriceGroupId priceGroupId
   137→        )
   138→
   139→        // Get pricing for a specific product at a specific store
   140→        @ProductPricing getProductPricing(@ProductId productId, @StoreId storeId)
   141→
   142→        // Get all products in a category with pricing
   143→        @List<ProductWithPrice> getProductsByCategory(@ProductCategory category, @StoreId storeId)
   144→    }
   145→
   146→    // 2.2 ProductCatalogETLService
   147→    // -----------------------------
   148→    // ETL service that ingests D365 Commerce pricing exports from S3.
   149→    // Validates data contract compliance and loads into RDS PostgreSQL.
   150→    Service ProductCatalogETLService {
   151→        // Process hourly pricing export from D365 Commerce
   152→        void processS3Export(@S3Location s3Location)
   153→
   154→        // Extract pricing data from Parquet files
   155→        @RawPricingData extractFromParquet(@S3Location s3Location)
   156→
   157→        // Transform D365 Commerce data into ProductPrice aggregate
   158→        @List<ProductPrice> transformPricingData(@RawPricingData rawData)
   159→
   160→        // Load transformed data into RDS PostgreSQL
   161→        void loadToDatabase(@List<ProductPrice> productPrices)
   162→
   163→        // Track ETL job execution
   164→        void recordETLRun(@ETLRunStatus status)
   165→    }
   166→
   167→    // 2.3 DataValidationService
   168→    // --------------------------
   169→    // Validates incoming pricing data against schema and business rules.
   170→    // Publishes DataValidationFailed events when validation fails.
   171→    Service DataValidationService {
   172→        // Validate pricing data against schema
   173→        @ValidationResult validateSchema(@RawPricingData rawData)
   174→
   175→        // Validate business rules (price > 0, effective dates, etc.)
   176→        @ValidationResult validateBusinessRules(@List<ProductPrice> productPrices)
   177→
   178→        // Validate store assignments exist in store master
   179→        @ValidationResult validateStoreAssignments(@List<StoreAssignment> assignments)
   180→    }
   181→
   182→    // 2.4 D365PricingTranslator (Anti-Corruption Layer)
   183→    // ---------------------------------------------------
   184→    // Translates D365 Commerce terminology and data structures into ProductCatalog domain language.
   185→    // Protects ProductCatalog domain from D365 Commerce model changes.
   186→    Service D365PricingTranslator {
   187→        // Translate D365 product model to OTR Product entity
   188→        @Product translateProduct(@D365Product d365Product)
   189→
   190→        // Translate D365 pricing model to OTR Price entity
   191→        @Price translatePrice(@D365Price d365Price)
   192→
   193→        // Translate D365 price group to OTR PriceGroup entity
   194→        @PriceGroup translatePriceGroup(@D365PriceGroup d365PriceGroup)
   195→    }
   196→
   197→    // 2.5 CacheInvalidationService (Future)
   198→    // ---------------------------------------
   199→    // Manages API Gateway cache invalidation when new pricing data is loaded.
   200→    // Future enhancement: ElastiCache integration for distributed caching.
   201→    Service CacheInvalidationService {
   202→        // Invalidate API Gateway cache for updated products
   203→        void invalidateCache(@List<ProductId> productIds)
   204→
   205→        // Invalidate entire cache after ETL completion
   206→        void invalidateAllCache()
   207→    }
   208→
   209→    // ========================================================================
   210→    // SECTION 3: VALUE OBJECTS (Shared)
   211→    // ========================================================================
   212→
   213→    ValueObject PricingResponse {
   214→        - DateTime generatedAt
   215→        - List<ProductWithPrice> products
   216→        - ResponseMetadata metadata
   217→    }
   218→
   219→    ValueObject ProductWithPrice {
   220→        - ProductId productId
   221→        - String productName
   222→        - ProductCategory category
   223→        - List<PriceForGroup> prices
   224→    }
   225→
   226→    ValueObject PriceForGroup {
   227→        - PriceGroupId priceGroup
   228→        - Money amount
   229→        - Date effectiveFrom
   230→        - Date effectiveTo
   231→        - List<StoreId> stores
   232→    }
   233→
   234→    ValueObject ResponseMetadata {
   235→        - int totalProducts
   236→        - DateTime lastUpdated
   237→    }
   238→
   239→    ValueObject S3Location {
   240→        - String bucket
   241→        - String key
   242→    }
   243→
   244→    ValueObject RawPricingData {
   245→        - List<D365Product> products
   246→        - List<D365Price> prices
   247→        - List<D365PriceGroup> priceGroups
   248→        - List<D365StoreAssignment> storeAssignments
   249→    }
   250→
   251→    ValueObject D365Product {
   252→        - String productNumber
   253→        - String productName
   254→        - String category
   255→    }
   256→
   257→    ValueObject D365Price {
   258→        - String productNumber
   259→        - String priceGroup
   260→        - Decimal amount
   261→        - String effectiveFrom
   262→        - String effectiveTo
   263→    }
   264→
   265→    ValueObject D365PriceGroup {
   266→        - String priceGroupId
   267→        - String priceGroupName
   268→        - String regionCode
   269→    }
   270→
   271→    ValueObject D365StoreAssignment {
   272→        - int storeId
   273→        - String priceGroupId
   274→        - String effectiveFrom
   275→    }
   276→
   277→    ValueObject ValidationResult {
   278→        - boolean isValid
   279→        - List<String> errors
   280→        - List<String> warnings
   281→    }
   282→
   283→    ValueObject ETLRunStatus {
   284→        - DateTime runTimestamp
   285→        - String status                  // SUCCESS | FAILED | IN_PROGRESS
   286→        - int recordsProcessed
   287→        - String errorMessage
   288→        - String sourceFilePath
   289→    }
   290→
   291→    // ========================================================================
   292→    // SECTION 4: DOMAIN EVENTS
   293→    // ========================================================================
   294→    // Events published for future extensibility.
   295→    // Initial implementation (Subway DMB) does not require event consumers.
   296→    // ========================================================================
   297→
   298→    // 4.1 Product Pricing Events
   299→    // ---------------------------
   300→    DomainEvent ProductPriceUpdated {
   301→        - ProductId productId
   302→        - String productName
   303→        - PriceGroupId priceGroupId
   304→        - Money oldPrice
   305→        - Money newPrice
   306→        - Date effectiveFrom
   307→        - DateTime updatedAt
   308→    }
   309→
   310→    DomainEvent ProductCatalogRefreshed {
   311→        - DateTime refreshedAt
   312→        - int productsUpdated
   313→        - int pricesUpdated
   314→        - String sourceFilePath
   315→    }
   316→
   317→    DomainEvent PriceGroupAssignmentChanged {
   318→        - PriceGroupId priceGroupId
   319→        - StoreId storeId
   320→        - String changeType              // ADDED | REMOVED | MODIFIED
   321→        - Date effectiveFrom
   322→        - DateTime changedAt
   323→    }
   324→
   325→    DomainEvent ProductAdded {
   326→        - ProductId productId
   327→        - String productName
   328→        - ProductCategory category
   329→        - DateTime addedAt
   330→    }
   331→
   332→    DomainEvent ProductRemoved {
   333→        - ProductId productId
   334→        - String productName
   335→        - String reason                  // DISCONTINUED | DELISTED | etc.
   336→        - DateTime removedAt
   337→    }
   338→
   339→    // 4.2 Data Quality Events
   340→    // ------------------------
   341→    DomainEvent DataValidationFailed {
   342→        - String validationType          // SCHEMA | BUSINESS_RULE | STORE_ASSIGNMENT
   343→        - List<String> errors
   344→        - String sourceFilePath
   345→        - DateTime failedAt
   346→    }
   347→
   348→    DomainEvent ETLPipelineFailed {
   349→        - String pipelineStage           // EXTRACT | TRANSFORM | LOAD
   350→        - String errorMessage
   351→        - String sourceFilePath
   352→        - DateTime failedAt
   353→    }
   354→
   355→    DomainEvent MissingPricingData {
   356→        - DateTime expectedAt
   357→        - String expectedFilePath
   358→        - DateTime detectedAt
   359→    }
   360→}
   361→
   362→// ============================================================================
   363→// INTEGRATION NOTES
   364→// ============================================================================
   365→//
   366→// Upstream Integration: D365 Commerce → ProductCatalogService
   367→// ------------------------------------------------------------
   368→// Pattern: Customer-Supplier + Conformist
   369→//
   370→// - D365 Commerce (Supplier): Exports pricing data to S3 on hourly schedule
   371→// - ProductCatalogService (Customer): Conforms to D365's data contract and schema
   372→// - Integration Technology: S3 bucket with cross-account IAM access (Azure → AWS)
   373→// - Data Format: Apache Parquet files with defined schema
   374→// - Update Frequency: Hourly batch export
   375→// - Anti-Corruption Layer: D365PricingTranslator translates D365 terminology into OTR domain language
   376→// - Eventually Consistent: Max 1 hour lag from D365 Commerce
   377→//
   378→// Downstream Integration: ProductCatalogService → External Consumers
   379→// -------------------------------------------------------------------
   380→// Pattern: Open Host Service + Published Language
   381→//
   382→// - ProductCatalogService (Open Host): Publishes stable REST API contract
   383→// - External Consumers (Amped Digital DMB, future mobile/web): Consume API without translation
   384→// - Integration Technology: REST API via API Gateway, OAuth 2.0 Client Credentials authentication
   385→// - Data Format: JSON with OpenAPI specification
   386→// - Update Frequency: Real-time queries (data eventually consistent, max 1 hour lag)
   387→// - Published Language: OTR domain terminology (product, price, store, price group)
   388→//
   389→// Cross-Cloud Integration
   390→// ------------------------
   391→// Pattern: Domain Boundary via S3 Data Contract
   392→//
   393→// - Back-Office Domain (Azure): D365 Commerce, Azure Data Lake, Microsoft Fabric
   394→// - Ecommerce Domain (AWS): S3, Glue/Lambda, RDS PostgreSQL, API Gateway, ECS
   395→// - Domain Interface: S3 bucket with data contract (schema, SLA, quality rules)
   396→// - Rationale: Clean separation between domains; each uses native cloud services
   397→//
   398→// What ProductCatalogService Owns
   399→// ---------------------------------
   400→// - Cached product pricing data (ProductPrice aggregate in RDS PostgreSQL)
   401→// - ETL pipeline logic (extract, transform, load from D365 exports)
   402→// - Data validation rules and quality monitoring
   403→// - API contract and Published Language for external consumers
   404→// - Event publishing for pricing changes
   405→//
   406→// What ProductCatalogService Does NOT Own (Owned by D365 Commerce)
   407→// ------------------------------------------------------------------
   408→// - Authoritative product master data
   409→// - Pricing configuration and rules
   410→// - Store master data
   411→// - Price group assignments and mappings
   412→// - Promotional pricing (future: owned by EagleEye)
   413→// - Inventory availability (future: owned by D365 Commerce)
   414→//
   415→// Future Event Consumers
   416→// -----------------------
   417→// Potential downstream consumers for pricing change events:
   418→//
   419→// - LocationService: Update store-specific pricing for store finder
   420→// - MobileApp: Invalidate cached prices, show "price updated" notifications
   421→// - EngagementService: Trigger "price drop" campaigns for customer engagement
   422→// - Data Platform: Analytics and reporting on pricing changes
   423→//
   424→// ============================================================================
   425→