= Mobile Application Interface
O.Young@otr.com.au
v0.1, 2025-12-19
:project-name: OTRG Apps & Ecommerce Architecture
:togaf-adm-phase: Phase C: Information Systems Architectures
:document-type: Bounded Context
:status: Draft
:version: 0.1
:domain: Mobile Application
:bounded-context-type: APPLICATION
:domain-architect: O.Young@otr.com.au
:doctype: article
:toc: left
:toclevels: 4
:sectanchors:
:sectlinks:
:sectnums:
:icons: font
:source-highlighter: highlightjs
:experimental:
:description: Mobile Application Interface (iOS/Android)
:keywords: mobile, ios, android, kotlin multiplatform, bounded context, togaf, ddd

Native mobile application providing iOS and Android users with access to
OTR's digital loyalty platform, mobile payments, store location, and
personalised offers. Built with Kotlin Multiplatform for shared business
logic and platform-native UI frameworks (SwiftUI for iOS, Jetpack
Compose for Android).

== Domain Vision Statement

Native mobile
application (iOS/Android) providing customers with mobile payments,
loyalty programme access, store location, and personalised offers with
offline-first architecture ## Application Scope ### Both OTR App and SPS
App This bounded context represents BOTH mobile applications: - *OTR
App*: Services OTR-branded stores - *SPS App*: Services Reddy Express
(REXP) stores *Shared Infrastructure:* - Same backend APIs
(LoyaltyService, PaymentService, etc.) - Same Kotlin Multiplatform
shared business logic - Same architecture patterns and security model -
Same offline-first capabilities *Key Differences:* - Branding (UI theme,
logos, colours) - Store filtering (OTR stores vs REXP stores) - Reward
preference defaults (based on store type) *Architectural Rationale:* -
Single logical bounded context because both apps consume identical
backend contracts - Maintains consistency in API design and feature
parity - Simplifies backend evolution (one API versioning strategy) -
Supports 5-year transition as REXP stores convert to OTR brand ##
Responsibilities - Mobile payment flows (Apple Pay, Google Pay, Samsung
Pay) - Pay-at-pump fuel pre-authorisation - Biometric authentication
integration - Loyalty programme interaction (points, offers, tiers) -
Store finder with geofencing and proximity features - Push notification
handling and in-app messaging - Offline capability with background sync
- Customer authentication (OAuth 2.0 + PKCE) - Secure token and payment
method storage - Customer feedback and survey submissions ##
Implementation Technology Kotlin Multiplatform (shared business logic),
iOS (SwiftUI, PassKit), Android (Jetpack Compose, Google Pay API), Azure
Notification Hubs, OAuth 2.0 + PKCE, Secure Storage (Keychain/Keystore)
## Platform Architecture ### Technology Stack - *Kotlin Multiplatform
(KMP)*: Shared business logic, API clients, data models, offline sync -
*iOS UI*: Native SwiftUI with PassKit for Apple Pay integration -
*Android UI*: Native Jetpack Compose with Google Pay API integration -
*Platform-Specific*: Payment integrations, biometric auth, push
notifications - *Offline-First*: Shared local data caching with
background sync when online ### Shared Components (Kotlin Multiplatform)
- Business logic layer - API clients (Ktor HTTP client) - Data models
and DTOs - Offline sync engine - Network layer with retry logic - State
management (Kotlin Flow) - Local database (SQLDelight, encrypted at
rest)

== Platform-Specific Components

=== iOS (SwiftUI)

* PassKit framework for Apple Pay
* Apple Wallet integration (future: loyalty card pass)
* Face ID / Touch ID authentication
* iOS push notifications (APNs)
* iOS Keychain for secure storage
* SwiftUI bindings for state management

=== Android (Jetpack Compose)

* Google Pay API for Google Pay
* Google Pay Passes (future: loyalty card pass)
* Fingerprint / Face unlock authentication
* Android push notifications (FCM)
* Android Keystore for secure storage
* Compose State for state management

== Key Capabilities

=== 1. Mobile Payments (CY26 Priority)

* Apple Pay integration (PassKit framework, Face ID/Touch ID)
* Google Pay integration (Google Pay API, biometric auth)
* Samsung Pay integration (Android)
* Pay-at-pump fuel pre-authorisation
* Offline payment queue (sync when network restored)

=== 2. Loyalty Programme

* Points balance and transaction history
* Tier status and benefits
* Offer activation and redemption
* Partner linking (Flybuys, AFL, etc.)
* Digital fuel dockets

=== 3. Location Services

* Store finder with map view
* Real-time fuel pricing
* Geofencing for proximity offers
* Navigation to selected store

=== 4. Engagement

* Push notifications (offers, rewards, receipts)
* In-app messaging
* Campaign content delivery
* Customer feedback and surveys

=== 5. Authentication

* OAuth 2.0 + PKCE with Microsoft Entra External ID
* Biometric authentication (Face ID, Touch ID, fingerprint)
* Social login (Google, Facebook, Apple)
* Secure token storage (iOS Keychain, Android Keystore)

== API Integration

=== Backend Services

* *LoyaltyService*: Points balance, transaction history, tier status
* *PaymentService*: Payment methods, mobile wallet tokenisation,
transactions
* *LocationService*: Store finder, fuel pricing, proximity features
* *EngagementService*: Campaigns, notifications, customer feedback
* *RecommendationService*: Personalised offers and product
recommendations

=== Integration Pattern

*Conformist Consumer*: Mobile app directly uses backend service DTOs
without translation layer

* Backend owns the API contract
* Mobile app conforms for simplicity
* Coupled to backend API changes (mitigated by API versioning)
* No Anti-Corruption Layer (simplifies client code)

== Offline Capabilities

=== Local Caching

* Loyalty balance and transaction history
* Store locations and fuel pricing (with staleness indicator)
* Active offers and wallet contents
* Customer profile data

=== Offline Queue

* Offline payment queue (queued until network available)
* Offer activation requests
* Feedback submissions
* Partner linking operations

=== Background Sync

* Automatic sync when network restored
* Optimistic UI updates with conflict resolution
* Server-wins conflict strategy (no local writes to authoritative data)

== Security

=== Data Protection

* Certificate pinning for API calls
* OAuth 2.0 access tokens with automatic refresh
* Biometric authentication for sensitive operations
* Payment tokens encrypted in secure storage (Keychain/Keystore)
* No storage of actual card details (PCI DSS compliance)

=== Secure Storage

* *iOS*: Keychain for tokens and payment methods
* *Android*: Keystore for tokens and payment methods
* No sensitive data in UserDefaults/SharedPreferences
* Encrypted at-rest local database (SQLDelight)

=== Authentication Flow

* OAuth 2.0 + PKCE with Microsoft Entra External ID
* Access tokens stored in secure storage
* Automatic token refresh with refresh tokens
* Automatic session timeout after inactivity
* Jailbreak/root detection (warn user of security risk)

== Apple Pay Integration (iOS)

=== Payment Flow

[arabic]
. Customer taps ``Pay with Apple Pay''
. App invokes `PassKit.presentPaymentauthorisationViewController()`
. Customer authenticates with Face ID/Touch ID
. Apple Secure Element generates device-specific payment token
. PassKit returns token to app
. App sends token to `PaymentService.tokenizeApplePayMethod()`
. PaymentService stores encrypted token
. Future payments use stored token (no re-authentication needed)

=== Requirements

* PassKit framework integration
* Apple Developer merchant ID
* Payment processing certificate
* Face ID/Touch ID capability

== Google Pay Integration (Android)

=== Payment Flow

[arabic]
. Customer taps ``Pay with Google Pay''
. App invokes Google Pay API (`PaymentsClient.loadPaymentData()`)
. Customer authenticates with fingerprint/face unlock
. Google generates PAN token
. Google Pay API returns token to app
. App sends token to `PaymentService.tokenizeGooglePayMethod()`
. PaymentService stores encrypted token
. Future payments use stored token

=== Requirements

* Google Pay API integration
* Google Pay merchant ID
* Payment gateway token specification
* Biometric authentication capability

== Offline Payment Queue

=== Queue Processing

[arabic]
. Customer initiates payment while offline
. App queues payment in local SQLite database
. App displays ``Payment queued, will process when online'' message
. Background sync monitors network connectivity
. When online, background job processes queue (FIFO order)
. *Success*: Remove from queue, update UI
. *Failure*: Retry with exponential backoff (3 attempts max)
. *After 3 failures*: Notify customer, require manual retry

=== Queue Item Structure

* Queue item ID (unique identifier)
* Operation type (PAYMENT, OFFER_ACTIVATION, FEEDBACK, PARTNER_LINK)
* Payload data (JSON serialised)
* Queued timestamp
* Retry count
* Last retry timestamp

== Local Data Models

=== Value Objects

==== LocalWalletCache

* Points balance (Money)
* Tier status (String)
* Active offers (List of LocalOffer)
* Last synced timestamp
* Staleness indicator (boolean)

==== LocalOffer

* Offer ID
* Offer name
* Description
* Discount value (Money)
* Expiry timestamp
* Activation status (boolean)

==== LocalTransactionHistory

* Transaction list (List of LocalTransaction)
* Last synced timestamp
* Staleness indicator (boolean)

==== LocalTransaction

* Transaction ID
* Transaction amount (Money)
* Transaction date
* Store name
* Receipt URL
* Points earned (int)

==== LocalPaymentMethod

* Payment method ID
* Payment method type (APPLE_PAY, GOOGLE_PAY, CREDIT_CARD, etc.)
* Last 4 digits
* Default flag (boolean)
* Display name (e.g., ``Visa •••• 1234'')

==== BiometricAuthConfig

* Biometric enabled flag (boolean)
* Available biometric type (FACE_ID, TOUCH_ID, FINGERPRINT, FACE_UNLOCK,
NONE)
* Require for payments flag (boolean)
* Require for loyalty redemption flag (boolean)

==== OfflineQueueItem

* Queue item ID
* Operation type (PAYMENT, OFFER_ACTIVATION, FEEDBACK_SUBMISSION,
PARTNER_LINK)
* Payload data (Map)
* Queued timestamp
* Retry count
* Last retry timestamp

== Push Notifications

=== Technology

* *iOS*: Apple Push Notification Service (APNs)
* *Android*: Firebase Cloud Messaging (FCM)
* *Orchestration*: Azure Notification Hubs

=== Notification Types

* Offer and reward notifications
* Campaign messages
* Transaction receipts
* Tier status changes
* Payment confirmations
* System alerts

== Analytics and Monitoring

=== Application Insights

* Crash reporting and diagnostics
* Performance telemetry
* User behaviour analytics
* API call monitoring
* Offline queue metrics

=== Tracked Events

* User authentication
* Payment transactions
* Offer activations
* Store searches
* Navigation patterns
* Error occurrences

== Implementation Notes

=== Development Environment

* *iOS*: Xcode project with SwiftUI
* *Android*: Android Studio project with Jetpack Compose
* *Shared*: Kotlin Multiplatform module

=== Network Layer

* Ktor Client (shared KMP) with retry logic
* Certificate pinning configuration
* Request/response interceptors
* Automatic token refresh

=== State Management

* Kotlin Flow (shared KMP)
* SwiftUI bindings (iOS)
* Compose State (Android)

=== Local Storage

* SQLDelight (shared KMP) for local caching
* Encrypted at rest
* Schema versioning and migrations

== Security Considerations

=== Certificate Pinning

* Prevents man-in-the-middle (MITM) attacks
* Configured for all backend API calls
* Pin rotation strategy for certificate updates

=== Session Management

* Automatic session timeout after inactivity
* Secure token refresh mechanism
* Session invalidation on security events

=== Device Security

* Jailbreak/root detection
* User warning for compromised devices
* Restricted functionality on rooted devices

=== PCI DSS Compliance

* No storage of actual card details
* Payment tokens only stored in secure storage
* Encrypted transmission of payment data
* Minimal PCI scope for mobile app

== What OTR Does NOT Control

* Apple Pay platform availability and terms
* Google Pay platform availability and terms
* Push notification service reliability (APNs, FCM)
* App store review processes and policies
* Mobile OS update cycles and compatibility
* Third-party SDK updates and behaviour
* Device biometric hardware capabilities
