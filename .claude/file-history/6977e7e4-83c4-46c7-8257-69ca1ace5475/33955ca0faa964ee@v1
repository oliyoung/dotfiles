---
Domain Architect: O.Young@otr.com.au
---
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Repository Purpose

This is a Domain-Driven Design (DDD) architecture repository for OTR Group's digital platform. It uses Context Mapper (CML) files to model bounded contexts (Loyalty, Payment, Engagement, Delivery, Location, Recommendation), domain aggregates, and system integrations following strategic DDD patterns.

**Important:** This architecture represents a **target state vision**. The platform will evolve incrementally from the current AWS-based monolithic API ("OTR App API") to this DDD architecture through phased extraction of bounded contexts. Current work (Google/Apple Pay, Flybuys integration) will be built using existing architecture while applying DDD patterns where practical.

## Working with Context Mapper Files

### File Structure

```
context-maps/        # System-level context maps showing relationships between bounded contexts
domains/             # Domain definitions (Loyalty, Payment, Location, Engagement, Recommendation)
bounded-contexts/    # Detailed bounded context definitions with aggregates and entities
  ├── external/      # External system integrations (EagleEye, Braze, Flybuys, etc.)
  ├── interfaces/    # Presentation layer contexts (Mobile, Web)
  ├── *.cml          # Domain model definitions (CML syntax)
  └── *.md           # Architecture documentation paired with CML files
diagrams/            # Auto-generated PNG diagrams (do not edit manually)
initiatives/         # Initiative documents describing specific implementation projects
templates/           # Document templates for consistent structure
  └── initiative_template.adoc  # Template for new initiative documents
```

### CML and Markdown File Pairing

**IMPORTANT:** CML files should predominantly contain domain model structure (aggregates, entities, value objects, services, events). Architecture decisions, rationale, and contextual reasoning should be documented in paired markdown files.

#### Structure Convention

Each major bounded context has two files:

- **`{context}.cml`** - Domain model in Context Mapper Language
  - Imports, bounded context definition
  - Aggregates, entities, value objects
  - Domain events, services, repositories
  - Minimal inline comments (aggregate invariants, entity descriptions)

- **`{context}.md`** - Architecture documentation
  - Overview and responsibilities
  - Architecture decision log (rationale, trade-offs, alternatives)
  - Integration patterns and bounded context boundaries
  - Key architectural patterns applied
  - DDD principles and future work

#### Examples

**Good CML file** (concise header, references markdown):

```cml
/*
 * ProfileService - Bounded Context Definition
 * ============================================
 *
 * See profile.md for architecture documentation and decision log.
 */

import "../domains/profile.cml"

BoundedContext ProfileService implements ProfileDomain {
    // Domain model here
}
```

**Good Markdown file** (comprehensive documentation):

```markdown
# ProfileService - Bounded Context

## Architecture Decision Log

### Decision 1: ProfileService Bridges Salesforce and OTR Ecosystem

**Decision:** ProfileService acts as an Anti-Corruption Layer...
**Rationale:** ...detailed reasoning...
**Implementation:** ...specific details...
```

#### When to Update Which File

**Update CML file when:**

- Adding/modifying aggregates, entities, or value objects
- Changing domain events or services
- Updating aggregate invariants
- Refactoring domain model structure

**Update Markdown file when:**

- Making architectural decisions
- Changing integration patterns
- Documenting trade-offs or alternatives considered
- Adding context about why decisions were made
- Explaining bounded context boundaries

#### Benefits of Separation

- **Cleaner CML** - Focus on domain model structure without lengthy prose
- **Better searchability** - Markdown easier to grep for decisions
- **Easier maintenance** - Update architecture docs without touching CML syntax
- **Better readability** - Markdown formatting with proper sections
- **Separation of concerns** - Structure vs. reasoning clearly separated

### Diagram Generation

Diagrams are automatically generated from CML files via GitHub Actions when:

- Changes to `*.cml` files are pushed to main/master branch
- Workflow is manually triggered via GitHub Actions UI

#### Local diagram generation

```bash

# Download Context Mapper CLI (one-time setup)

mkdir -p context-mapper
cd context-mapper
wget https://github.com/ContextMapper/context-mapper-cli/releases/download/v6.11.0/context-mapper-cli-6.11.0.jar

# Generate diagrams from a CML file

java -jar context-mapper/context-mapper-cli-6.11.0.jar \
  -i path/to/file.cml \
  -o diagrams/ \
  -f ContextMap \
  -t PNG

# For component diagrams

java -jar context-mapper/context-mapper-cli-6.11.0.jar \
  -i path/to/file.cml \
  -o diagrams/ \
  -f PLANTUML \
  -t PNG
```

### Prerequisites for Local Development

- Java 17 or higher
- Graphviz (for diagram rendering)
- Context Mapper VS Code extension (recommended for CML editing)

## Architecture Overview

### TO-BE Architecture

The context maps define a **target state** architecture using DDD strategic patterns:

#### Core BFF Services

- **LoyaltyService**: BFF/facade orchestrating loyalty operations - owns transaction adjudication audit trail and partner link status; queries wallet, points, tiers, and campaigns from EagleEye
- **EngagementService**: Customer engagement, campaigns, notifications
- **RecommendationService**: Personalized recommendations, next-best offers
- **LocationService**: Store finder, proximity features, geofencing
- **PaymentService**: Payment processing, subscription billing

##### External Systems

- **EagleEye**: SaaS loyalty engine (points, offers, promotions)
- **Braze**: Marketing automation platform
- **D365 Commerce**: E-commerce and product catalog
- **Flybuys**: Coalition loyalty partner
- **Salesforce**: Customer profile system of record (CRM)
- **Microsoft Entra External ID**: Customer Identity and Access Management (CIAM) - Authentication and authorisation

###### Presentation Layer

- **MobileApp**: iOS & Android native apps

### Integration Patterns Used

1. **[Anti-Corruption Layer (ACL)](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#anti-corruption-layer-acl)**: Protects core services from external system changes
   - Used for: EagleEye, Braze, RecommendationExternalService, PaymentService integrations
   - Bidirectional ACL for systems that call each other

2. **[Customer-Supplier](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#customer-supplier) with [Conformist](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#conformist)**: External systems we don't control
   - Used for: Flybuys, Salesforce, Microsoft Entra External ID, D365 Commerce
   - We conform to their API contracts to simplify integration

3. **[Open Host Service (OHS)](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#open-host-service-ohs) + [Published Language (PL)](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#published-language)**: Event-driven internal integration
   - LoyaltyService publishes [domain events](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#domain-event) via Event Bus
   - Consumed by EngagementService and RecommendationService
   - Events: CustomerEnrolled, PointsEarned, PointsRedeemed, GrantIssued, etc.

4. **Conformist Pattern**: Presentation layer clients
   - Mobile app consumes BFF REST APIs without translation
   - Simplifies client code, backend owns the contract

## Key Architectural Discoveries

### LoyaltyService Bounded Context Analysis

Through systematic DDD bounded context analysis, LoyaltyService was refined from an initial design with 8 aggregates down to **only 2 aggregates**:

1. **RewardTransaction**: transaction adjudication audit trail
2. **PartnerLink**: External partner linking status (Flybuys, Shell)

#### What LoyaltyService Owns (Aggregates)

- transaction adjudication results and reward history summaries
- Partner linking status (not OAuth tokens - those are managed by infrastructure OAuth Service)

##### What LoyaltyService Orchestrates (via ACL)

- transaction adjudication calls to EagleEye
- Wallet, points, tier, and campaign queries from EagleEye
- Customer preference queries from Profile/CRM
- Event publishing from EagleEye webhooks (translates EagleEye notifications into OTR domain events)

###### What Other Systems Own

- **EagleEye**: Wallet (grants, offers), points ledger, membership/tiers, campaigns/promotions
- **Profile/CRM**: Customer reward preferences
- **OAuth Service**: OAuth tokens for partner integrations (generic infrastructure service)
- **SubscriptionService** (separate bounded context): Subscription plans, billing, payment coordination
- **POS Context**: Transaction transactions, line items, receipts

**Core Pattern**: LoyaltyService is a **Backend-for-Frontend (BFF)** and **Anti-Corruption Layer** that:

- Orchestrates loyalty operations across multiple systems
- Translates between external systems (EagleEye) and OTR's domain language
- Publishes domain events for other bounded contexts to consume
- Queries external systems in real-time (simplicity over local caching)

See `ARCHITECTURE_DECISIONS.md` for detailed rationale behind each decision, including why transaction transactions, customer preferences, OAuth tokens, wallet, points ledger, membership, campaigns, and subscriptions don't belong in LoyaltyService.

See `application-layer/loyalty-application-services.md` for the complete transaction adjudication flow with orchestration logic.

## Domain-Driven Design Principles

### Socratic Approach

This repository follows a learning-focused approach to DDD. When making architectural changes:

1. **Understand the business domain first** - What capability are we supporting? What are the business rules?
2. **Identify bounded contexts** - Where are natural boundaries? What changes independently?
3. **Define aggregates carefully** - What needs transactional consistency? What's the aggregate root?
4. **Choose integration patterns deliberately** - Consider coupling, resilience, and control

### Ubiquitous Language

CML files use business terminology from OTR operations:

- **Viva Consumer ID**: Universal customer identifier
- **transaction adjudication**: Determining reward eligibility from purchase transactions
- **Reward Preference**: Customer's choice of reward partner (Flybuys, Shell Price Save, OTR Rewards)
- **Wallet**: Collection of grants, entitlements, offers, and fuel discounts
- **Points Ledger**: Historical record of points accrual, redemption, and expiry

### Aggregate Design

Each [bounded context](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#bounded-context) CML file defines [aggregates](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#aggregate) with:

- **[Aggregate Root](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#aggregate)**: [Entity](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#entity) that controls access to the aggregate
- **Invariants**: Business rules that must always be true
- **[Entities](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#entity)**: Objects with identity that belong to the aggregate
- **[Value Objects](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#value-object)**: Immutable objects defined by their attributes

Example from LoyaltyService (after bounded context analysis):

- `RewardTransaction` [aggregate](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#aggregate): Records transaction adjudication results and reward history (summary only, not full transaction)
- `PartnerLink` [aggregate](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#aggregate): Tracks customer linkage to external partners (Flybuys, Shell) - linking status only, OAuth tokens managed separately

**Note**: After DDD [bounded context](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#bounded-context) analysis, LoyaltyService was simplified from 8 aggregates down to 2. See `ARCHITECTURE_DECISIONS.md` for the full rationale. Key insight: LoyaltyService is a [BFF](Domain-Driven%2520Design%2520%28DDD)%20Glossary.md#backend-for-frontend-bff)/facade that orchestrates and translates, not a system of record for loyalty data (EagleEye owns wallet, points, tiers, campaigns).

## OTR Group Context

### Current Projects Referenced

- **Braze Migration**: Transitioning from Salesforce Marketing Cloud (6.7M subscribers)
- **Promotional Rules Engine**: Evaluating Eagle Eye replacement
- **Customer Feedback Surveys**: "Ready to Listen" system integration
- **Loyalty Tracking**: Store conversion tracking (Reddy Express → OTR, 1000 stores)
- **Digital Wallet**: Value statement and implementation architecture
- **Partner Integrations**: AFL, Budget Direct, Flybuys

### Technical Stack

- **Mobile App Platform**: AWS (serverless functions, managed services)
- **Back Office Platform**: Azure (existing systems, Microsoft Fabric for data platform)
- **Backend Services**: C#/.NET
- **Mobile Development**: Kotlin Multiplatform (shared business logic), SwiftUI (iOS UI), Jetpack Compose (Android UI)
- **Integration**: REST APIs, Event Bus (EventBridge/Kinesis/SNS+SQS), Webhooks
- **Event-Driven**: Event Bus for domain events (technology TBD)
- **Databases**: NoSQL (LoyaltyService), Relational (EngagementService) - specific platforms TBD
- **Authentication**: Existing CIAM Service or cloud-native CIAM (TBD)

### Organizational Model

Three-tier architecture governance:

1. **Business Owners**: Feature decisions, business rules, priorities
2. **Domain Architects**: Bounded contexts, integration patterns, technical strategy
3. **Senior Engineers**: Implementation patterns, code structure, technology choices

## Making Changes

### When Adding/Modifying Bounded Contexts

1. Start with business capability and stakeholder needs
2. Define clear aggregate boundaries with invariants in CML file
3. Use appropriate integration patterns (ACL, Customer-Supplier, OHS+PL)
4. **Document domain model in CML file** (aggregates, entities, events, services)
5. **Document architecture decisions in paired markdown file** (rationale, trade-offs, patterns)
6. Ensure ubiquitous language consistency across related contexts and both files

### When Adding External System Integrations

1. Determine control level: Do we control the API? Do they?
2. Choose pattern:
   - **Bidirectional ACL**: Both systems evolve independently
   - **Customer-Supplier + Conformist**: We conform to their API
   - **ACL only**: We protect our domain from their changes
3. **Model integration in CML file** - define upstream/downstream relationships, ACL adapters
4. **Document integration decisions in markdown** - technology choice (REST/Webhooks), data flow, error handling, resilience patterns, rationale for pattern choice

### CML File Guidelines

- **Keep CML files focused on domain model structure** - aggregates, entities, value objects, events, services
- **Reference paired markdown file** in header comment for architecture documentation
- **Minimal inline comments** - only for aggregate invariants, entity descriptions, and technical notes
- **Specify implementation technology** for bounded context (not in comments, use implementationTechnology attribute)
- **Maintain consistency with ubiquitous language** across all definitions
- **Reference related context maps and domains** via imports
- **Document architecture decisions in markdown** - see paired `.md` file for rationale and trade-offs

### Git Workflow

- Changes to `*.cml` files automatically trigger diagram regeneration
- Diagrams are committed back to the repository with `[skip ci]` tag
- Always pull before pushing to avoid diagram conflicts
- If diagram conflicts occur, delete local diagrams and let workflow regenerate

## Documentation Strategy

### Bridging Code and High-Level Design

CML files serve as a bridge between:

- **Code structures** ↔ Architecture documents
- **Bounded contexts** ↔ Technical design descriptions
- **Domain events** ↔ Integration specifications
- **Aggregates** ↔ Data flow diagrams

### What Belongs in CML vs Markdown

**In CML comments (minimal):**

1. **Aggregate invariants** - Business rules that must always hold true for the aggregate
2. **Entity/Value Object descriptions** - Brief explanations of domain concepts
3. **Technical constraints** - Implementation-specific notes (e.g., "15-character Salesforce ID")
4. **Reference to markdown** - Header comment pointing to paired `.md` file

**In Markdown files (comprehensive):**

1. **Business context** - Capability being supported, stakeholder needs, domain overview
2. **Architecture decisions** - Why this pattern? What are the trade-offs? Alternatives considered?
3. **Integration patterns** - Technology choices, synchronous vs. async, error handling, resilience
4. **Bounded context boundaries** - What this context owns vs. what other systems own
5. **Key architectural patterns** - ACL, BFF, Event-Driven, etc. with detailed explanations
6. **DDD principles applied** - How DDD tactical and strategic patterns are used
7. **Future work** - Planned enhancements, technical debt, known limitations

### Markdown Documentation Standards

All markdown files in this repository follow strict linting standards:

#### MD036 - Emphasis Used Instead of Heading

**Never use bold text as a heading.** Always use proper heading syntax (#, ##, ###, etc.)

**Bad:**

```markdown
**This is a section**
Some content here.
```

**Good:**

```markdown
### This is a section

Some content here.
```

#### MD022 - Headings Should Be Surrounded by Blank Lines

**Always surround headings with blank lines** (one blank line before and after each heading).

**Bad:**

```markdown
Some paragraph text.
### Heading Without Spacing
More content here.
```

**Good:**

```markdown
Some paragraph text.

### Heading With Proper Spacing

More content here.
```

#### Heading Hierarchy

Use all six heading levels appropriately:

- **H1 (#)**: Document title (one per document)
- **H2 (##)**: Major sections
- **H3 (###)**: Subsections
- **H4 (####)**: Sub-subsections
- **H5 (#####)**: Further nested sections
- **H6 (######)**: Deepest level sections

Don't skip heading levels (e.g., don't jump from H2 to H4).

## Resources

- [Context Mapper Documentation](https://contextmapper.org/)
- [CML Language Reference](https://contextmapper.org/docs/language-reference/)
- [DDD Patterns in Context Mapper](https://contextmapper.org/docs/ddd-patterns/)
- [Context Mapper CLI](https://github.com/ContextMapper/context-mapper-cli)

## Key Principles for AI Assistance

When working on this repository, remember:

1. **Ask clarifying questions** about business domain before suggesting solutions
2. **Explain trade-offs** of architectural patterns, not just prescribe them
3. **Use OTR-specific examples** from current projects when possible
4. **Bridge technical and business language** for different stakeholders
5. **Challenge tight coupling** and help identify aggregate boundaries
6. **Focus on resilience** in distributed systems with legacy integrations
7. **Maintain ubiquitous language** consistency across all contexts
8. **Australian English**
9. **One question at a time** when building documentation conversationally - avoid overwhelming with multiple questions in a single response
