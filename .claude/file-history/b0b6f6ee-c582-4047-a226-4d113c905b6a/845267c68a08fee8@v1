= Clean Architecture
:description: Clean Architecture layering and dependency rules for OTR digital platform
:keywords: clean architecture, hexagonal architecture, ports and adapters, layering, dependency inversion

== Overview

The OTR digital platform follows **Clean Architecture** principles (also known as Hexagonal Architecture or Ports and Adapters) to ensure:

- Business logic independence from frameworks and external systems
- Testability through dependency inversion
- Flexibility to swap infrastructure components
- Clear separation of concerns across layers

.Clean Architecture Layers
image::https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg[Clean Architecture Diagram]

**Reference**: Robert C. Martin (Uncle Bob), https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html[The Clean Architecture^]

== The Dependency Rule

**The overriding rule**: Source code dependencies must point **inward only**.

[source]
----
Infrastructure → Application → Domain
     ↓              ↓
External Systems must depend on abstractions defined in Domain
----

Nothing in an inner circle can know anything about something in an outer circle:
- Domain layer cannot import from Application or Infrastructure
- Application layer cannot import from Infrastructure
- Infrastructure layer imports from Domain (via interfaces)

== Layer Responsibilities

=== Domain Layer (Innermost)

**Purpose**: Enterprise business rules and domain logic

**Contains**:

- **Aggregates**: Cluster of domain objects treated as a single unit (e.g., `RewardTransaction`, `PartnerLink`)
- **Entities**: Objects with identity and lifecycle (e.g., `Customer`, `LoyaltyMember`)
- **Value Objects**: Immutable objects defined by attributes (e.g., `PointsBalance`, `PartnerIdentifier`)
- **Domain Services**: Stateless operations that don't belong to a single aggregate (e.g., `TransactionAdjudicationService`)
- **Domain Events**: Record of something that happened in the domain (e.g., `PointsEarned`, `PartnerLinked`)
- **Repository Interfaces**: Abstract contracts for data persistence (implementations in Infrastructure)
- **Domain Exceptions**: Business rule violations (e.g., `InsufficientPointsException`)

**Dependencies**: None (pure business logic)

**Example** (LoyaltyService):
[source]
----
Domain/
├── Aggregates/
│   ├── RewardTransaction.cs
│   └── PartnerLink.cs
├── ValueObjects/
│   ├── PointsBalance.cs
│   └── TransactionSummary.cs
├── Services/
│   └── ITransactionAdjudicationService.cs
├── Events/
│   ├── PointsEarned.cs
│   └── TransactionAdjudicated.cs
├── Repositories/
│   └── IRewardTransactionRepository.cs
└── Exceptions/
    └── InvalidPartnerLinkException.cs
----

=== Application Layer

**Purpose**: Application-specific business rules and use case orchestration

**Contains**:

- **Use Cases / Interactors**: Single application operation (e.g., `ProcessLoyaltyTransaction`, `LinkPartnerAccount`)
- **Application Services**: Coordinate multiple domain objects for use case (e.g., `LoyaltyApplicationService`)
- **DTOs (Data Transfer Objects)**: Data structures for transferring data between layers
- **Input/Output Ports**: Interfaces for presentation and infrastructure (Dependency Inversion)
- **Application Events**: Application-level events (may wrap domain events)
- **Queries**: Read-only operations (CQRS pattern)

**Dependencies**: Domain layer only

**Example** (LoyaltyService):
[source]
----
Application/
├── UseCases/
│   ├── ProcessLoyaltyTransaction/
│   │   ├── ProcessLoyaltyTransactionUseCase.cs
│   │   ├── ProcessLoyaltyTransactionInput.cs
│   │   └── ProcessLoyaltyTransactionOutput.cs
│   └── LinkPartnerAccount/
│       ├── LinkPartnerAccountUseCase.cs
│       ├── LinkPartnerAccountInput.cs
│       └── LinkPartnerAccountOutput.cs
├── Services/
│   └── LoyaltyApplicationService.cs
├── DTOs/
│   ├── LoyaltyTransactionDto.cs
│   └── PartnerLinkDto.cs
├── Ports/
│   ├── ILoyaltyPlatformPort.cs  (EagleEye abstraction)
│   ├── IProfileServicePort.cs   (ProfileService abstraction)
│   └── IEventBusPort.cs
└── Queries/
    └── GetPointsBalanceQuery.cs
----

=== Infrastructure Layer (Outermost)

**Purpose**: Implementation details - frameworks, databases, external systems

**Contains**:

- **Repository Implementations**: Concrete data access (e.g., `SqlRewardTransactionRepository`)
- **External Service Adapters**: Anti-Corruption Layers for external systems (e.g., `EagleEyeAdapter`)
- **Framework Adapters**: Web frameworks, ORMs, message buses
- **Configuration**: Database connections, API keys, environment settings
- **Persistence**: Database schemas, migrations

**Dependencies**: Application and Domain layers (implements their interfaces)

**Example** (LoyaltyService):
[source]
----
Infrastructure/
├── Persistence/
│   ├── Repositories/
│   │   └── SqlRewardTransactionRepository.cs
│   ├── EntityConfigurations/
│   │   └── RewardTransactionConfiguration.cs
│   └── LoyaltyDbContext.cs
├── ExternalServices/
│   ├── EagleEye/
│   │   ├── EagleEyeAdapter.cs         (implements ILoyaltyPlatformPort)
│   │   ├── EagleEyeClient.cs
│   │   └── EagleEyeModels.cs          (external API models)
│   ├── Flybuys/
│   │   └── FlybuysAdapter.cs
│   └── ProfileService/
│       └── ProfileServiceAdapter.cs    (implements IProfileServicePort)
├── EventBus/
│   └── EventBridgeAdapter.cs          (implements IEventBusPort)
└── Configuration/
    └── DependencyInjection.cs
----

=== Presentation Layer (API Controllers / BFF)

**Purpose**: Interface adapters for external clients

**Contains**:

- **REST Controllers**: HTTP endpoints (e.g., `LoyaltyController`)
- **GraphQL Resolvers**: GraphQL endpoint handlers
- **Request/Response Models**: API contracts (different from DTOs)
- **Authentication/Authorization**: API security
- **Input Validation**: Request validation
- **Response Formatting**: Transform DTOs to API responses

**Dependencies**: Application layer (calls use cases)

**Example** (LoyaltyService BFF):
[source]
----
Presentation/
├── Controllers/
│   ├── LoyaltyController.cs
│   └── PartnerLinkController.cs
├── Models/
│   ├── Requests/
│   │   ├── ProcessTransactionRequest.cs
│   │   └── LinkPartnerRequest.cs
│   └── Responses/
│       ├── TransactionResponse.cs
│       └── PointsBalanceResponse.cs
├── Middleware/
│   └── AuthenticationMiddleware.cs
└── Validators/
    └── ProcessTransactionRequestValidator.cs
----

== Backend-for-Frontend (BFF) Pattern

A **BFF** is a specialized Presentation layer optimized for a specific client (mobile app, web app, digital menu board).

**Key Characteristics**:

- Sits in the Presentation layer (outermost)
- Aggregates data from multiple Application layer use cases
- Formats responses for specific client needs
- Does NOT contain business logic (delegates to Application/Domain)
- May call multiple bounded contexts to assemble responses

**Example**: Mobile BFF aggregates data from LoyaltyService, ProfileService, and LocationService to show "My Account" screen.

.BFF is Presentation Layer, Not Domain
[IMPORTANT]
====
A service can be BOTH:

- A **bounded context** (owns domain aggregates and business rules)
- A **BFF** (exposes Presentation layer optimized for mobile clients)

Example: **LoyaltyService** is:

- A bounded context (owns `RewardTransaction` aggregate with business rules)
- Has a BFF presentation layer (REST API optimized for mobile app)

The BFF is the **outermost layer** of the bounded context, not the bounded context itself.
====

== Dependency Inversion Principle (Ports & Adapters)

**Problem**: Application/Domain layers need infrastructure services (database, external APIs) but cannot depend on them.

**Solution**: Define abstractions (ports) in Application/Domain, implement in Infrastructure (adapters).

=== Ports (Interfaces)

Defined in Application or Domain layer:

[source,csharp]
----
// Application/Ports/ILoyaltyPlatformPort.cs
public interface ILoyaltyPlatformPort
{
    Task<AdjudicationResult> AdjudicateTransaction(
        TransactionDetails transaction,
        CustomerContext customer);

    Task<PointsBalance> GetPointsBalance(CustomerId customerId);
}
----

=== Adapters (Implementations)

Implemented in Infrastructure layer:

[source,csharp]
----
// Infrastructure/ExternalServices/EagleEye/EagleEyeAdapter.cs
public class EagleEyeAdapter : ILoyaltyPlatformPort
{
    private readonly IEagleEyeClient _client;

    public async Task<AdjudicationResult> AdjudicateTransaction(
        TransactionDetails transaction,
        CustomerContext customer)
    {
        // Translate OTR domain model → EagleEye API model
        var eagleEyeRequest = MapToEagleEyeModel(transaction, customer);

        // Call external system
        var eagleEyeResponse = await _client.PostTransaction(eagleEyeRequest);

        // Translate EagleEye response → OTR domain model
        return MapToDomainModel(eagleEyeResponse);
    }
}
----

**Benefits**:

- Domain/Application layers testable without real infrastructure
- External systems swappable (replace EagleEye with different platform)
- Clear Anti-Corruption Layer boundary

== Testing Strategy

Clean Architecture enables comprehensive testing at each layer:

=== Unit Tests (Domain Layer)

Test business logic in complete isolation:

[source,csharp]
----
[Test]
public void RewardTransaction_Should_CalculateCorrectPoints()
{
    // Arrange
    var transaction = new RewardTransaction(
        customerId: "12345",
        transactionAmount: 100.00m);

    // Act
    var points = transaction.CalculatePoints(scheme: LoyaltyScheme.Flybuys);

    // Assert
    Assert.That(points, Is.EqualTo(100)); // 1 point per dollar
}
----

**No mocking required** - pure domain logic.

=== Integration Tests (Application Layer)

Test use cases with in-memory infrastructure:

[source,csharp]
----
[Test]
public async Task ProcessLoyaltyTransaction_Should_PublishPointsEarnedEvent()
{
    // Arrange
    var inMemoryRepository = new InMemoryRewardTransactionRepository();
    var fakeEventBus = new FakeEventBus();
    var fakeLoyaltyPlatform = new FakeLoyaltyPlatform();

    var useCase = new ProcessLoyaltyTransactionUseCase(
        inMemoryRepository,
        fakeEventBus,
        fakeLoyaltyPlatform);

    // Act
    await useCase.Execute(new ProcessLoyaltyTransactionInput { ... });

    // Assert
    Assert.That(fakeEventBus.PublishedEvents, Has.One.TypeOf<PointsEarnedEvent>());
}
----

**Mocks for ports** - test application orchestration without real infrastructure.

=== Component Tests (Infrastructure Layer)

Test adapters with stubbed external services:

[source,csharp]
----
[Test]
public async Task EagleEyeAdapter_Should_TranslateToOtrDomainModel()
{
    // Arrange
    var stubbedEagleEyeApi = WireMock.CreateServer();
    stubbedEagleEyeApi.Given(Request.Create().WithPath("/adjudicate"))
        .RespondWith(Response.Create().WithBody(eagleEyeJsonResponse));

    var adapter = new EagleEyeAdapter(new EagleEyeClient(stubbedEagleEyeApi.Url));

    // Act
    var result = await adapter.AdjudicateTransaction(transaction, customer);

    // Assert
    Assert.That(result.PointsEarned, Is.EqualTo(150));
}
----

**Stubbed external APIs** - test ACL translation without hitting real systems.

=== End-to-End Tests

Test complete flow through all layers:

[source,csharp]
----
[Test]
public async Task CompleteLoyaltyFlow_Should_ProcessFromApiToDatabase()
{
    // Arrange
    var testServer = new TestServer(CreateWebHostBuilder());
    var client = testServer.CreateClient();

    // Act
    var response = await client.PostAsync("/api/loyalty/transactions", jsonContent);

    // Assert
    Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.OK));
    var transaction = await GetTransactionFromDatabase(transactionId);
    Assert.That(transaction.Status, Is.EqualTo(TransactionStatus.Completed));
}
----

== Eventual Consistency Patterns

In distributed systems with event-driven architecture, eventual consistency is managed at the Application layer:

=== Saga Pattern

For multi-step processes across bounded contexts:

[source,csharp]
----
// Application/Sagas/PartnerLinkingSaga.cs
public class PartnerLinkingSaga
{
    public async Task Execute(LinkPartnerAccountCommand command)
    {
        // Step 1: Link account in ProfileService
        await _profileService.CreatePartnerLink(command.CustomerId, command.PartnerId);

        // Step 2: Activate in external partner system
        var activationResult = await _partnerAdapter.ActivateAccount(command);

        if (!activationResult.Success)
        {
            // Compensating action: Remove link from ProfileService
            await _profileService.RemovePartnerLink(command.CustomerId, command.PartnerId);
            throw new PartnerActivationFailedException();
        }

        // Step 3: Publish event for other services
        await _eventBus.Publish(new PartnerLinkedEvent(command.CustomerId, command.PartnerId));
    }
}
----

=== Event Sourcing

For audit trail and rebuilding state:

[source,csharp]
----
// Domain/Aggregates/RewardTransaction.cs
public class RewardTransaction : AggregateRoot
{
    public void RecordAdjudication(AdjudicationResult result)
    {
        // Apply domain event
        Apply(new TransactionAdjudicatedEvent
        {
            TransactionId = Id,
            PointsEarned = result.PointsEarned,
            Timestamp = DateTime.UtcNow
        });
    }

    private void Apply(TransactionAdjudicatedEvent @event)
    {
        // Update aggregate state
        PointsEarned = @event.PointsEarned;
        Status = TransactionStatus.Adjudicated;
    }
}
----

=== Read Models (CQRS)

For eventually consistent queries:

[source,csharp]
----
// Application/Queries/GetCustomerLoyaltySummaryQuery.cs
public class GetCustomerLoyaltySummaryQuery
{
    private readonly ILoyaltySummaryReadModel _readModel;

    public async Task<CustomerLoyaltySummary> Execute(CustomerId customerId)
    {
        // Query denormalized read model (eventual consistency acceptable)
        return await _readModel.GetSummary(customerId);
    }
}

// Infrastructure event handler updates read model
public class PointsEarnedEventHandler
{
    public async Task Handle(PointsEarnedEvent @event)
    {
        // Update denormalized read model
        await _loyaltySummaryRepository.UpdatePointsBalance(
            @event.CustomerId,
            @event.PointsEarned);
    }
}
----

== Applying Clean Architecture to OTR Services

Each bounded context follows Clean Architecture:

|===
|Layer |LoyaltyService Example |ProfileService Example |EngagementService Example

|**Domain**
|`RewardTransaction` aggregate, `TransactionAdjudicationService`
|`CustomerProfile` aggregate, `RiskAssessmentService`
|`CustomerInquiry` aggregate, `InquiryClassificationService`

|**Application**
|`ProcessLoyaltyTransactionUseCase`, `LinkPartnerAccountUseCase`
|`CreateCustomerProfileUseCase`, `UpdateRewardPreferenceUseCase`
|`CreateSupportRequestUseCase`, `SendCampaignUseCase`

|**Infrastructure**
|`EagleEyeAdapter` (ACL), `FlybuysAdapter` (ACL), `SqlRewardTransactionRepository`
|`SalesforceAdapter` (ACL), `CosmosDbProfileRepository`
|`BrazeAdapter` (ACL), `SalesforceServiceCloudAdapter` (ACL)

|**Presentation (BFF)**
|REST API for mobile app (`LoyaltyController`)
|REST API for mobile app (`ProfileController`)
|REST API + Event handlers (`EngagementController`)
|===

== References

- Robert C. Martin, https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html[The Clean Architecture^]
- Alistair Cockburn, https://alistair.cockburn.us/hexagonal-architecture/[Hexagonal Architecture^]
- Vernon, Vaughn. *Implementing Domain-Driven Design*. Addison-Wesley, 2013.
- Martin, Robert C. *Clean Architecture: A Craftsman's Guide to Software Structure and Design*. Prentice Hall, 2017.
