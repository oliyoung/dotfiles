= ProductCatalog Infrastructure Implementation
:description: Infrastructure layer implementation details for ProductCatalogService
:keywords: infrastructure, aws, postgresql, implementation, deployment

== Overview

This document describes the **Infrastructure Layer** implementation for ProductCatalogService, following xref:../patterns/clean_architecture.adoc[Clean Architecture] principles.

**Separation of Concerns**:

- xref:../bounded-contexts/product_catalog.adoc[ProductCatalog Bounded Context]: Domain model, business rules, ports (interfaces)
- **This Document**: Concrete implementations, deployment architecture, infrastructure choices

== Infrastructure Adapters

Following the **Ports & Adapters** pattern, infrastructure layer implements interfaces defined in Application layer.

=== Repository Implementations

==== PostgreSQL Product Price Repository

**Port**: `IProductPriceRepository` (defined in Application layer)

**Adapter**: `PostgreSqlProductPriceRepository` (Infrastructure layer)

[source,csharp]
----
// Infrastructure/Persistence/PostgreSqlProductPriceRepository.cs
public class PostgreSqlProductPriceRepository : IProductPriceRepository
{
    private readonly ProductCatalogDbContext _context;

    public async Task<ProductPrice> FindById(ProductId id)
    {
        var entity = await _context.ProductPrices
            .Include(p => p.PriceGroup)
            .FirstOrDefaultAsync(p => p.Id == id.Value);

        return entity != null ? MapToDomainModel(entity) : null;
    }

    public async Task<List<ProductPrice>> FindByStoreId(StoreId storeId)
    {
        var entities = await _context.ProductPrices
            .Include(p => p.PriceGroup)
            .ThenInclude(pg => pg.StoreAssignments)
            .Where(p => p.PriceGroup.StoreAssignments.Any(sa => sa.StoreId == storeId.Value))
            .ToListAsync();

        return entities.Select(MapToDomainModel).ToList();
    }

    public async Task Save(ProductPrice productPrice)
    {
        var entity = MapToEntity(productPrice);
        _context.ProductPrices.Update(entity);
        await _context.SaveChangesAsync();
    }

    private ProductPrice MapToDomainModel(ProductPriceEntity entity)
    {
        // Map EF entity → Domain aggregate
        return new ProductPrice(
            productId: new ProductId(entity.ProductId),
            priceAmount: entity.PriceAmount,
            priceGroup: new PriceGroup(entity.PriceGroupId),
            effectiveFrom: entity.EffectiveFrom,
            effectiveTo: entity.EffectiveTo);
    }
}
----

=== Database Schema (PostgreSQL)

==== Products Table

[source,sql]
----
CREATE TABLE products (
    product_id VARCHAR(50) PRIMARY KEY,
    product_name VARCHAR(255) NOT NULL,
    product_category VARCHAR(100),
    last_updated TIMESTAMP NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT product_name_not_empty CHECK (LENGTH(product_name) > 0)
);

CREATE INDEX idx_products_category ON products(product_category);
CREATE INDEX idx_products_last_updated ON products(last_updated);
----

==== Price Groups Table

[source,sql]
----
CREATE TABLE price_groups (
    price_group_id VARCHAR(50) PRIMARY KEY,
    price_group_name VARCHAR(255),
    region_code VARCHAR(10),
    last_updated TIMESTAMP NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT region_code_valid CHECK (region_code IN ('AU-NSW', 'AU-VIC', 'AU-QLD', 'AU-WA', 'AU-SA', 'AU-TAS', 'AU-ACT', 'AU-NT'))
);

CREATE INDEX idx_price_groups_region ON price_groups(region_code);
----

==== Product Prices Table

[source,sql]
----
CREATE TABLE product_prices (
    id SERIAL PRIMARY KEY,
    product_id VARCHAR(50) NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    price_group_id VARCHAR(50) NOT NULL REFERENCES price_groups(price_group_id) ON DELETE CASCADE,
    price_amount DECIMAL(10, 2) NOT NULL CHECK (price_amount > 0),
    effective_from DATE NOT NULL,
    effective_to DATE,
    last_updated TIMESTAMP NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (product_id, price_group_id, effective_from),
    CONSTRAINT effective_dates_valid CHECK (effective_to IS NULL OR effective_to > effective_from)
);

CREATE INDEX idx_product_prices_product ON product_prices(product_id);
CREATE INDEX idx_product_prices_price_group ON product_prices(price_group_id);
CREATE INDEX idx_product_prices_effective_dates ON product_prices(effective_from, effective_to);
----

==== Store Assignments Table

[source,sql]
----
CREATE TABLE store_assignments (
    id SERIAL PRIMARY KEY,
    store_id INTEGER NOT NULL,
    price_group_id VARCHAR(50) NOT NULL REFERENCES price_groups(price_group_id) ON DELETE CASCADE,
    effective_from DATE NOT NULL,
    effective_to DATE,
    last_updated TIMESTAMP NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (store_id, price_group_id, effective_from),
    CONSTRAINT effective_dates_valid CHECK (effective_to IS NULL OR effective_to > effective_from)
);

CREATE INDEX idx_store_assignments_store ON store_assignments(store_id);
CREATE INDEX idx_store_assignments_price_group ON store_assignments(price_group_id);
----

==== ETL Job Tracking Table

[source,sql]
----
CREATE TABLE etl_runs (
    id SERIAL PRIMARY KEY,
    job_id UUID NOT NULL UNIQUE,
    run_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) NOT NULL CHECK (status IN ('IN_PROGRESS', 'SUCCESS', 'FAILED')),
    records_processed INTEGER,
    error_message TEXT,
    source_file_path VARCHAR(500),
    started_at TIMESTAMP NOT NULL,
    completed_at TIMESTAMP,
    duration_seconds INTEGER GENERATED ALWAYS AS (EXTRACT(EPOCH FROM (completed_at - started_at))) STORED
);

CREATE INDEX idx_etl_runs_status ON etl_runs(status);
CREATE INDEX idx_etl_runs_timestamp ON etl_runs(run_timestamp DESC);
----

=== External System Adapters

==== D365 Commerce Adapter (Anti-Corruption Layer)

**Port**: `ID365CommercePort`

**Adapter**: `D365CommerceS3Adapter`

[source,csharp]
----
// Infrastructure/ExternalServices/D365Commerce/D365CommerceS3Adapter.cs
public class D365CommerceS3Adapter : ID365CommercePort
{
    private readonly IAmazonS3 _s3Client;
    private readonly string _bucketName;
    private readonly string _prefix;

    public async Task<PricingDataExport> FetchLatestPricingExport()
    {
        // 1. List objects in S3 bucket
        var listRequest = new ListObjectsV2Request
        {
            BucketName = _bucketName,
            Prefix = $"{_prefix}/pricing/",
            MaxKeys = 1
        };

        var listResponse = await _s3Client.ListObjectsV2Async(listRequest);
        var latestFile = listResponse.S3Objects
            .OrderByDescending(o => o.LastModified)
            .FirstOrDefault();

        if (latestFile == null)
        {
            throw new PricingExportNotFoundException("No pricing exports found in S3");
        }

        // 2. Download file
        var getRequest = new GetObjectRequest
        {
            BucketName = _bucketName,
            Key = latestFile.Key
        };

        using var response = await _s3Client.GetObjectAsync(getRequest);
        using var reader = new StreamReader(response.ResponseStream);

        // 3. Parse Parquet file → Domain model
        var parquetData = await ParquetReader.ReadAsync(reader.BaseStream);

        // 4. Translate D365 Commerce model → OTR domain model
        return new PricingDataExport
        {
            ExportId = Path.GetFileNameWithoutExtension(latestFile.Key),
            Products = parquetData.Select(TranslateProduct).ToList(),
            Prices = parquetData.Select(TranslatePrice).ToList(),
            ExportedAt = latestFile.LastModified
        };
    }

    private Product TranslateProduct(dynamic d365Product)
    {
        // ACL: Translate D365 Commerce terminology → OTR ubiquitous language
        return new Product(
            productId: new ProductId(d365Product.ItemId), // D365: "ItemId" → OTR: "ProductId"
            productName: d365Product.Name,
            category: d365Product.Category);
    }
}
----

=== Infrastructure Services

==== API Gateway Cache Adapter

**Port**: `ICachePort`

**Adapter**: `ApiGatewayCacheAdapter`

[source,csharp]
----
// Infrastructure/Caching/ApiGatewayCacheAdapter.cs
public class ApiGatewayCacheAdapter : ICachePort
{
    private readonly IDistributedCache _cache; // API Gateway integrated cache

    public async Task<T> Get<T>(string key)
    {
        var cachedData = await _cache.GetStringAsync(key);
        return cachedData != null
            ? JsonSerializer.Deserialize<T>(cachedData)
            : default;
    }

    public async Task Set<T>(string key, T value, TimeSpan ttl)
    {
        var options = new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = ttl
        };

        var serialized = JsonSerializer.Serialize(value);
        await _cache.SetStringAsync(key, serialized, options);
    }

    public async Task Invalidate(string key)
    {
        await _cache.RemoveAsync(key);
    }
}
----

==== CloudWatch Observability Adapter

**Port**: `IObservabilityPort`

**Adapter**: `CloudWatchObservabilityAdapter`

[source,csharp]
----
// Infrastructure/Observability/CloudWatchObservabilityAdapter.cs
public class CloudWatchObservabilityAdapter : IObservabilityPort
{
    private readonly ILogger<CloudWatchObservabilityAdapter> _logger;
    private readonly IAmazonCloudWatch _cloudWatch;

    public void LogInformation(string message, params object[] args)
    {
        _logger.LogInformation(message, args);
    }

    public void LogError(Exception ex, string message, params object[] args)
    {
        _logger.LogError(ex, message, args);
    }

    public void RecordMetric(string metricName, double value)
    {
        var request = new PutMetricDataRequest
        {
            Namespace = "ProductCatalog",
            MetricData = new List<MetricDatum>
            {
                new MetricDatum
                {
                    MetricName = metricName,
                    Value = value,
                    Unit = StandardUnit.Count,
                    TimestampUtc = DateTime.UtcNow
                }
            }
        };

        _cloudWatch.PutMetricDataAsync(request);
    }
}
----

== AWS Infrastructure

=== Service Architecture

[source]
----
┌─────────────────────────────────────────────────────────────┐
│  API Clients (Mobile App, DMB Platform)                      │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ↓
        ┌─────────────────────────────┐
        │  API Gateway                 │
        │  - OAuth 2.0 Authentication  │
        │  - Rate Limiting             │
        │  - Cache Layer               │
        │  - WAF Protection            │
        └──────────┬──────────────────┘
                   │
                   ↓
        ┌─────────────────────────────┐
        │  ECS Fargate                 │
        │  - ProductCatalog API        │
        │  - Auto-scaling (2-10 tasks) │
        │  - Health checks             │
        └──────┬──────────────┬────────┘
               │              │
               ↓              ↓
    ┌──────────────┐   ┌──────────────┐
    │ RDS PostgreSQL│   │ Secrets Mgr  │
    │ - Multi-AZ    │   │ - OAuth keys │
    │ - Automated   │   │ - DB creds   │
    │   backups     │   └──────────────┘
    └──────────────┘
               ↑
               │
    ┌──────────────────────────┐
    │  ETL Pipeline             │
    │  - AWS Glue Jobs (hourly) │
    │  - Lambda validators      │
    │  - S3 data source         │
    └──────────────────────────┘
----

=== Infrastructure Components

==== Compute: ECS Fargate

**Service**: ProductCatalog API

**Configuration**:
- Task Definition: 2 vCPU, 4 GB memory
- Auto-scaling: 2-10 tasks based on CPU/memory
- Health check: `/health` endpoint
- Deployment: Rolling update

**Task IAM Role Permissions**:
- Read from RDS PostgreSQL
- Read from S3 (pricing exports)
- Publish to EventBridge
- Read from Secrets Manager
- Write CloudWatch metrics/logs

==== Database: Amazon RDS PostgreSQL

**Instance**: db.t3.medium (2 vCPU, 4 GB RAM)

**Configuration**:
- Multi-AZ deployment for high availability
- Automated backups (7-day retention)
- Automated patching (maintenance window: Sunday 2AM AEST)
- Storage: 100 GB GP3 SSD, auto-scaling enabled
- Encryption at rest: AWS KMS
- Encryption in transit: TLS 1.2+

**Performance**:
- Read IOPS: 3000 baseline
- Connection pool: 100 connections
- Query timeout: 30 seconds

==== API Gateway

**Type**: HTTP API (lower cost than REST API)

**Configuration**:
- OAuth 2.0 JWT authorizer
- Throttling: 1000 requests/second per API key
- Burst: 2000 requests
- Cache TTL: 5 minutes (for pricing queries)
- CORS: Enabled for mobile app domain
- Custom domain: `api.otr.com.au/product-catalog/v1`

**WAF Rules**:
- Rate limiting: 100 requests/5 minutes per IP
- Geo-restriction: Australia only
- SQL injection protection
- XSS protection

==== ETL Pipeline: AWS Glue + Lambda

**Glue Job**: `ProductCatalog-ETL-Hourly`

**Schedule**: Cron expression `0 * * * ? *` (hourly)

**Configuration**:
- 2 DPU (Data Processing Units)
- Timeout: 15 minutes
- Max retries: 2
- Bookmark: Enabled (incremental processing)

**Lambda Validator**: `ProductCatalog-DataValidator`

**Trigger**: S3 object created in `pricing-exports/` prefix

**Configuration**:
- Memory: 512 MB
- Timeout: 5 minutes
- Runtime: .NET 6

**Validation**:
- Schema validation (Parquet schema matches contract)
- Business rule validation (price > 0, valid store IDs)
- Referential integrity (products exist before prices)

==== Observability: CloudWatch

**Metrics**:
- `ProductCatalog.ApiLatency` (p50, p95, p99)
- `ProductCatalog.ApiErrorRate` (4xx, 5xx)
- `ProductCatalog.ETLJobDuration`
- `ProductCatalog.ETLRecordsProcessed`
- `ProductCatalog.CacheHitRate`

**Alarms**:
- P1: API error rate > 1% for 5 minutes
- P1: ETL job failure
- P2: API latency p95 > 500ms for 10 minutes
- P2: Cache hit rate < 80%

**Logs**:
- Application logs: `/aws/ecs/product-catalog-api`
- ETL logs: `/aws/glue/product-catalog-etl`
- Retention: 30 days

==== Secrets Management: AWS Secrets Manager

**Secrets**:
- `product-catalog/db-credentials` - PostgreSQL credentials
- `product-catalog/oauth-client-secret` - OAuth client secret for DMB authentication
- `product-catalog/d365-api-key` - D365 Commerce API key (future)

**Rotation**:
- Database credentials: Auto-rotation every 90 days
- OAuth secrets: Manual rotation

== Deployment Architecture

=== Environment Strategy

|===
|Environment |Purpose |Infrastructure

|**Development**
|Developer testing
|Single AZ, t3.micro RDS, 1 ECS task

|**Staging**
|Pre-production validation
|Multi-AZ, t3.small RDS, 2 ECS tasks, mirrors production

|**Production**
|Live customer traffic
|Multi-AZ, t3.medium RDS, auto-scaling ECS (2-10 tasks)
|===

=== Deployment Pipeline

[source]
----
1. Git push to main branch
2. GitHub Actions triggered
3. Build Docker image
4. Run unit tests
5. Run integration tests (in-memory DB)
6. Push image to ECR
7. Deploy to Staging (ECS rolling update)
8. Run smoke tests on Staging
9. Manual approval gate
10. Deploy to Production (ECS rolling update)
11. Monitor CloudWatch alarms for 30 minutes
12. Rollback if error rate > 1%
----

=== Disaster Recovery

**RTO (Recovery Time Objective)**: 1 hour

**RPO (Recovery Point Objective)**: 5 minutes

**Backup Strategy**:
- RDS automated backups: Daily snapshot, 7-day retention
- Point-in-time recovery: 5-minute granularity
- S3 pricing exports: Versioning enabled, 90-day retention

**Recovery Procedure**:
1. Restore RDS from latest snapshot
2. Replay S3 pricing exports from last successful ETL job
3. Update ECS service to use restored RDS endpoint
4. Verify data integrity

== Cost Optimization

**Monthly Costs** (Production environment):

- RDS PostgreSQL db.t3.medium Multi-AZ: ~$150
- ECS Fargate (average 4 tasks): ~$120
- API Gateway requests (1M/month): ~$3
- CloudWatch logs/metrics: ~$20
- Data transfer: ~$10
- **Total: ~$303/month**

**Optimization Strategies**:
- Use HTTP API (not REST API) for lower cost
- Cache responses at API Gateway (reduces ECS invocations)
- Compress ETL data in S3 (reduces storage/transfer costs)
- Right-size RDS instance based on actual load

== Security

=== Network Security

- VPC with private subnets for RDS
- Security groups: ECS → RDS only on port 5432
- No public internet access to RDS
- NAT Gateway for ECS outbound S3/Secrets Manager access

=== Data Security

- Encryption at rest: AWS KMS for RDS, S3
- Encryption in transit: TLS 1.2+ for all connections
- Secrets rotation: Automated for DB credentials
- IAM roles (not API keys) for service-to-service auth

=== Application Security

- OAuth 2.0 client credentials flow for DMB authentication
- JWT validation at API Gateway
- Rate limiting per API key
- WAF protection (SQL injection, XSS)
- Input validation on all API endpoints

== Monitoring & Alerting

=== Key Metrics

|===
|Metric |Target |Alert Threshold

|API Latency (p95)
|< 500ms
|> 1000ms for 5 minutes

|API Error Rate
|< 0.5%
|> 1% for 5 minutes

|ETL Success Rate
|> 99%
|Single failure

|Cache Hit Rate
|> 80%
|< 70% for 10 minutes

|RDS CPU
|< 70%
|> 85% for 10 minutes

|RDS Connections
|< 80
|> 90
|===

=== Dashboards

**ProductCatalog - API Performance**:
- Request rate (requests/min)
- Latency (p50, p95, p99)
- Error rate (4xx, 5xx)
- Cache hit rate

**ProductCatalog - ETL Health**:
- Job success/failure rate
- Records processed per run
- Job duration
- Data freshness (time since last successful run)

== References

- xref:../bounded-contexts/product_catalog.adoc[ProductCatalog Bounded Context] (domain architecture)
- xref:../patterns/clean_architecture.adoc[Clean Architecture] (layering principles)
- AWS Well-Architected Framework: https://aws.amazon.com/architecture/well-architected/
