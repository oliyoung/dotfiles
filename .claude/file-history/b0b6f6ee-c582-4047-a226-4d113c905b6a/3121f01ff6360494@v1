= Loyalty Infrastructure Implementation
:description: Infrastructure layer implementation details for LoyaltyService
:keywords: infrastructure, aws, dynamodb, implementation, deployment, acl

== Overview

This document describes the **Infrastructure Layer** implementation for LoyaltyService, following xref:../patterns/clean_architecture.adoc[Clean Architecture] principles.

**Separation of Concerns**:

- xref:../bounded-contexts/loyalty.adoc[Loyalty Bounded Context]: Domain model, business rules, ports (interfaces)
- xref:../application-layer/loyalty/use-cases.adoc[Application Layer Use Cases]: Use cases, application services, orchestration
- **This Document**: Concrete implementations, deployment architecture, infrastructure choices

== Infrastructure Adapters

Following the **Ports & Adapters** pattern, infrastructure layer implements interfaces defined in Application layer.

=== Repository Implementations

==== DynamoDB Reward Transaction Repository

**Port**: `IRewardTransactionRepository` (defined in Application layer)

**Adapter**: `DynamoDbRewardTransactionRepository` (Infrastructure layer)

[source,csharp]
----
// Infrastructure/Persistence/DynamoDbRewardTransactionRepository.cs
public class DynamoDbRewardTransactionRepository : IRewardTransactionRepository
{
    private readonly IAmazonDynamoDB _dynamoDb;
    private readonly IObservabilityPort _observability;
    private const string TableName = "LoyaltyService-RewardTransactions";

    public async Task Save(RewardTransaction transaction)
    {
        var item = MapToDynamoDbItem(transaction);

        var putRequest = new PutItemRequest
        {
            TableName = TableName,
            Item = item,
            ConditionExpression = "attribute_not_exists(TransactionId)" // Idempotency
        };

        try
        {
            await _dynamoDb.PutItemAsync(putRequest);
            _observability.RecordMetric("RewardTransaction.Saved", 1);
        }
        catch (ConditionalCheckFailedException)
        {
            // Transaction already exists - idempotent operation
            _observability.LogInformation("Transaction {TransactionId} already exists",
                transaction.Id.Value);
        }
    }

    public async Task<RewardTransaction> FindById(TransactionId id)
    {
        var request = new GetItemRequest
        {
            TableName = TableName,
            Key = new Dictionary<string, AttributeValue>
            {
                ["TransactionId"] = new AttributeValue { S = id.Value }
            }
        };

        var response = await _dynamoDb.GetItemAsync(request);

        return response.Item.Count > 0
            ? MapToDomainModel(response.Item)
            : null;
    }

    public async Task<List<RewardTransaction>> FindByCustomerId(
        CustomerId customerId,
        int limit)
    {
        var request = new QueryRequest
        {
            TableName = TableName,
            IndexName = "CustomerIdIndex",
            KeyConditionExpression = "CustomerId = :customerId",
            ExpressionAttributeValues = new Dictionary<string, AttributeValue>
            {
                [":customerId"] = new AttributeValue { S = customerId.Value }
            },
            Limit = limit,
            ScanIndexForward = false // Most recent first
        };

        var response = await _dynamoDb.QueryAsync(request);

        return response.Items
            .Select(MapToDomainModel)
            .ToList();
    }

    public async Task<List<RewardTransaction>> FindByDateRange(
        DateTime from,
        DateTime to)
    {
        // Use ScanAsync for date range queries (less frequent query)
        var request = new ScanRequest
        {
            TableName = TableName,
            FilterExpression = "TransactionDate BETWEEN :from AND :to",
            ExpressionAttributeValues = new Dictionary<string, AttributeValue>
            {
                [":from"] = new AttributeValue { S = from.ToString("o") },
                [":to"] = new AttributeValue { S = to.ToString("o") }
            }
        };

        var response = await _dynamoDb.ScanAsync(request);

        return response.Items
            .Select(MapToDomainModel)
            .ToList();
    }

    private Dictionary<string, AttributeValue> MapToDynamoDbItem(RewardTransaction tx)
    {
        return new Dictionary<string, AttributeValue>
        {
            ["TransactionId"] = new AttributeValue { S = tx.Id.Value },
            ["CustomerId"] = new AttributeValue { S = tx.CustomerId.Value },
            ["TransactionDate"] = new AttributeValue { S = tx.TransactionDate.ToString("o") },
            ["PointsEarned"] = new AttributeValue { N = tx.PointsEarned.ToString() },
            ["SchemesParticipated"] = new AttributeValue
            {
                SS = tx.SchemesParticipated.Select(s => s.ToString()).ToList()
            },
            ["ItemCount"] = new AttributeValue { N = tx.ItemCount.ToString() },
            ["ItemSummary"] = new AttributeValue { S = tx.ItemSummary },
            ["SourceTransactionId"] = new AttributeValue { S = tx.SourceTransactionId }
        };
    }

    private RewardTransaction MapToDomainModel(Dictionary<string, AttributeValue> item)
    {
        // Map DynamoDB item → Domain aggregate
        return new RewardTransaction(
            id: new TransactionId(item["TransactionId"].S),
            customerId: new CustomerId(item["CustomerId"].S),
            transactionDate: DateTime.Parse(item["TransactionDate"].S),
            pointsEarned: int.Parse(item["PointsEarned"].N),
            schemesParticipated: item["SchemesParticipated"].SS
                .Select(s => Enum.Parse<LoyaltyScheme>(s))
                .ToList(),
            itemCount: int.Parse(item["ItemCount"].N),
            itemSummary: item["ItemSummary"].S,
            sourceTransactionId: item["SourceTransactionId"].S);
    }
}
----

=== Anti-Corruption Layer (ACL) Implementations

==== EagleEye Loyalty Platform Adapter

**Port**: `ILoyaltyPlatformPort` (defined in Application layer)

**Adapter**: `EagleEyeLoyaltyPlatformAdapter` (Infrastructure layer)

[source,csharp]
----
// Infrastructure/ExternalSystems/EagleEye/EagleEyeLoyaltyPlatformAdapter.cs
public class EagleEyeLoyaltyPlatformAdapter : ILoyaltyPlatformPort
{
    private readonly HttpClient _httpClient;
    private readonly ISecretsPort _secrets;
    private readonly IObservabilityPort _observability;

    public async Task<AdjudicationResult> AdjudicateTransaction(
        AdjudicationRequest request)
    {
        // Translate OTR domain model → EagleEye API contract
        var eagleEyeRequest = new
        {
            identity = new
            {
                identityValue = request.CustomerId.Value,
                type = "ACCOUNT_ID"
            },
            location = request.StoreId.Value,
            totalAmount = request.TotalAmount,
            basket = new
            {
                type = "STANDARD",
                contents = request.LineItems.Select(item => new
                {
                    sku = item.ProductId,
                    quantity = item.Quantity,
                    itemUnitCost = item.UnitPrice,
                    totalCost = item.TotalPrice
                }).ToArray()
            }
        };

        var response = await _httpClient.PostAsJsonAsync(
            "/transaction/adjudicate",
            eagleEyeRequest);

        response.EnsureSuccessStatusCode();

        var eagleEyeResponse = await response.Content
            .ReadFromJsonAsync<EagleEyeAdjudicationResponse>();

        // Translate EagleEye response → OTR domain model
        return new AdjudicationResult(
            transactionId: new TransactionId(eagleEyeResponse.TransactionId),
            pointsEarned: eagleEyeResponse.PointsAwarded,
            schemesParticipated: MapSchemes(eagleEyeResponse.SchemesProcessed),
            grantsIssued: eagleEyeResponse.GrantsIssued
                .Select(g => new GrantId(g.GrantId))
                .ToList(),
            offersRedeemed: eagleEyeResponse.OffersRedeemed
                .Select(o => new OfferId(o.OfferId))
                .ToList());
    }

    public async Task<PointsBalance> GetPointsBalance(
        CustomerId customerId,
        LoyaltyScheme scheme)
    {
        // Query EagleEye for points balance
        var response = await _httpClient.GetAsync(
            $"/accounts/{customerId.Value}/balance?scheme={MapSchemeToEagleEye(scheme)}");

        response.EnsureSuccessStatusCode();

        var eagleEyeBalance = await response.Content
            .ReadFromJsonAsync<EagleEyeBalanceResponse>();

        // Translate EagleEye → OTR domain model
        return new PointsBalance(
            scheme: scheme,
            currentBalance: eagleEyeBalance.Points,
            lifetimeEarned: eagleEyeBalance.LifetimePoints,
            expiringPoints: eagleEyeBalance.ExpiringPoints,
            expiryDate: eagleEyeBalance.ExpiryDate);
    }

    public async Task<Wallet> GetWallet(CustomerId customerId)
    {
        // Query EagleEye AIR Wallet API
        var response = await _httpClient.GetAsync(
            $"/wallet/{customerId.Value}");

        response.EnsureSuccessStatusCode();

        var eagleEyeWallet = await response.Content
            .ReadFromJsonAsync<EagleEyeWalletResponse>();

        // Translate EagleEye wallet → OTR domain model
        return new Wallet(
            grants: eagleEyeWallet.Grants.Select(MapGrant).ToList(),
            offers: eagleEyeWallet.Offers.Select(MapOffer).ToList(),
            storedValueBalance: eagleEyeWallet.StoredValue);
    }

    public async Task<List<Campaign>> GetActiveCampaigns(CustomerId customerId)
    {
        // Query EagleEye for active campaigns
        var response = await _httpClient.GetAsync(
            $"/campaigns/active?accountId={customerId.Value}");

        response.EnsureSuccessStatusCode();

        var eagleEyeCampaigns = await response.Content
            .ReadFromJsonAsync<EagleEyeCampaignsResponse>();

        // Translate EagleEye campaigns → OTR domain model
        return eagleEyeCampaigns.Campaigns
            .Select(c => new Campaign(
                id: new CampaignId(c.CampaignId),
                name: c.Name,
                description: c.Description,
                startDate: c.StartDate,
                endDate: c.EndDate,
                eligibleCustomer: c.Eligible))
            .ToList();
    }

    private List<LoyaltyScheme> MapSchemes(List<string> eagleEyeSchemes)
    {
        // Translate EagleEye scheme names → OTR domain model
        return eagleEyeSchemes
            .Select(s => s switch
            {
                "FLYBUYS" => LoyaltyScheme.FLYBUYS,
                "OTR_INTERNAL" => LoyaltyScheme.INTERNAL_OTR,
                _ => throw new ArgumentException($"Unknown scheme: {s}")
            })
            .ToList();
    }

    private string MapSchemeToEagleEye(LoyaltyScheme scheme)
    {
        return scheme switch
        {
            LoyaltyScheme.FLYBUYS => "FLYBUYS",
            LoyaltyScheme.INTERNAL_OTR => "OTR_INTERNAL",
            _ => throw new ArgumentException($"Unknown scheme: {scheme}")
        };
    }
}
----

**Configuration**:

- **Base URL**: Retrieved from AWS Secrets Manager
- **Authentication**: OAuth 2.0 Client Credentials (token cached in Redis)
- **Timeout**: 10 seconds (with exponential backoff retry)
- **Circuit Breaker**: Polly resilience policies

==== Flybuys Partner Platform Adapter

**Port**: `IPartnerPlatformPort` (defined in Application layer)

**Adapter**: `FlybuysPartnerPlatformAdapter` (Infrastructure layer - Conformist pattern)

[source,csharp]
----
// Infrastructure/ExternalSystems/Flybuys/FlybuysPartnerPlatformAdapter.cs
public class FlybuysPartnerPlatformAdapter : IPartnerPlatformPort
{
    private readonly HttpClient _httpClient;
    private readonly ISecretsPort _secrets;

    public async Task<string> GetMemberId(string accessToken)
    {
        // Flybuys OAuth userinfo endpoint
        _httpClient.DefaultRequestHeaders.Authorization =
            new AuthenticationHeaderValue("Bearer", accessToken);

        var response = await _httpClient.GetAsync("/oauth/userinfo");
        response.EnsureSuccessStatusCode();

        var userInfo = await response.Content
            .ReadFromJsonAsync<FlybuysUserInfo>();

        return userInfo.MemberId;
    }

    public async Task ActivateAccount(string memberId, ActivationRequest request)
    {
        // Activate Flybuys account for OTR rewards earning
        var flybuysRequest = new
        {
            memberId = memberId,
            partnerId = "OTR",
            activationDate = DateTime.UtcNow
        };

        var response = await _httpClient.PostAsJsonAsync(
            "/partners/otr/activate",
            flybuysRequest);

        response.EnsureSuccessStatusCode();
    }

    public async Task<PartnerBalance> GetBalance(string memberId)
    {
        // Query Flybuys points balance
        var response = await _httpClient.GetAsync(
            $"/members/{memberId}/balance");

        response.EnsureSuccessStatusCode();

        var flybuysBalance = await response.Content
            .ReadFromJsonAsync<FlybuysBalanceResponse>();

        return new PartnerBalance(
            currentBalance: flybuysBalance.Points,
            pendingPoints: flybuysBalance.PendingPoints);
    }
}
----

==== ProfileService Client

**Port**: `IProfileServicePort` (defined in Application layer)

**Adapter**: `ProfileServiceHttpClient` (Infrastructure layer - inter-service communication)

[source,csharp]
----
// Infrastructure/InternalServices/ProfileServiceHttpClient.cs
public class ProfileServiceHttpClient : IProfileServicePort
{
    private readonly HttpClient _httpClient;
    private readonly IObservabilityPort _observability;

    public async Task<CustomerContext> GetCustomerContext(CustomerId customerId)
    {
        // Call ProfileService internal API
        var response = await _httpClient.GetAsync(
            $"/api/internal/v1/customers/{customerId.Value}/context");

        response.EnsureSuccessStatusCode();

        var profileContext = await response.Content
            .ReadFromJsonAsync<ProfileContextResponse>();

        // Map ProfileService response → LoyaltyService domain model
        return new CustomerContext(
            customerId: customerId,
            rewardPreference: Enum.Parse<RewardPreference>(profileContext.RewardPreference),
            partnerLinks: profileContext.PartnerLinks
                .Select(pl => new PartnerLink(
                    partner: Enum.Parse<Partner>(pl.Partner),
                    status: Enum.Parse<LinkStatus>(pl.Status),
                    linkedDate: pl.LinkedDate))
                .ToList());
    }

    public async Task<List<PartnerLink>> GetPartnerLinks(CustomerId customerId)
    {
        var response = await _httpClient.GetAsync(
            $"/api/internal/v1/customers/{customerId.Value}/partner-links");

        response.EnsureSuccessStatusCode();

        var links = await response.Content
            .ReadFromJsonAsync<List<PartnerLinkResponse>>();

        return links
            .Select(l => new PartnerLink(
                partner: Enum.Parse<Partner>(l.Partner),
                status: Enum.Parse<LinkStatus>(l.Status),
                linkedDate: l.LinkedDate))
            .ToList();
    }
}
----

**Service Discovery**:

- **Development**: Hardcoded URL (http://localhost:5001)
- **AWS**: AWS Cloud Map service discovery

=== Infrastructure Service Implementations

==== EventBridge Event Bus

**Port**: `IEventBusPort` (defined in Application layer)

**Adapter**: `EventBridgeEventBus` (Infrastructure layer)

[source,csharp]
----
// Infrastructure/Messaging/EventBridgeEventBus.cs
public class EventBridgeEventBus : IEventBusPort
{
    private readonly IAmazonEventBridge _eventBridge;
    private readonly IObservabilityPort _observability;
    private const string EventBusName = "LoyaltyServiceEventBus";

    public async Task Publish<TEvent>(TEvent domainEvent)
        where TEvent : IDomainEvent
    {
        var eventEntry = new PutEventsRequestEntry
        {
            EventBusName = EventBusName,
            Source = "LoyaltyService",
            DetailType = domainEvent.GetType().Name,
            Time = DateTime.UtcNow,
            Detail = JsonSerializer.Serialize(domainEvent, new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            })
        };

        var request = new PutEventsRequest
        {
            Entries = new List<PutEventsRequestEntry> { eventEntry }
        };

        var response = await _eventBridge.PutEventsAsync(request);

        if (response.FailedEntryCount > 0)
        {
            _observability.LogError(
                new Exception("Event publishing failed"),
                "Failed to publish event {EventType}",
                domainEvent.GetType().Name);

            throw new EventPublishingException(
                $"Failed to publish {domainEvent.GetType().Name}");
        }

        _observability.RecordMetric("DomainEvent.Published", 1);
        _observability.LogInformation(
            "Published domain event {EventType} with ID {EventId}",
            domainEvent.GetType().Name,
            domainEvent.EventId);
    }
}
----

**EventBridge Configuration**:

- **Event Bus**: LoyaltyServiceEventBus (custom event bus)
- **Event Archive**: 30-day replay capability
- **Dead Letter Queue**: SQS queue for failed event processing
- **Schema Registry**: Event schemas registered for versioning

==== Redis Cache Implementation

**Port**: `ICachePort` (defined in Application layer)

**Adapter**: `RedisCacheAdapter` (Infrastructure layer)

[source,csharp]
----
// Infrastructure/Caching/RedisCacheAdapter.cs
public class RedisCacheAdapter : ICachePort
{
    private readonly IConnectionMultiplexer _redis;
    private readonly IObservabilityPort _observability;

    public async Task<T> Get<T>(string key)
    {
        var db = _redis.GetDatabase();
        var value = await db.StringGetAsync(key);

        if (value.IsNullOrEmpty)
        {
            _observability.RecordMetric("Cache.Miss", 1);
            return default;
        }

        _observability.RecordMetric("Cache.Hit", 1);
        return JsonSerializer.Deserialize<T>(value);
    }

    public async Task Set<T>(string key, T value, TimeSpan ttl)
    {
        var db = _redis.GetDatabase();
        var json = JsonSerializer.Serialize(value);

        await db.StringSetAsync(key, json, ttl);

        _observability.RecordMetric("Cache.Set", 1);
    }
}
----

**Redis Configuration**:

- **Service**: Amazon ElastiCache for Redis (Cluster Mode)
- **Node Type**: cache.r6g.large (2 vCPU, 13.07 GiB RAM)
- **Cluster**: 2 shards, 1 replica per shard (HA)
- **Encryption**: In-transit (TLS) and at-rest
- **Backup**: Daily snapshots, 7-day retention

==== CloudWatch Observability

**Port**: `IObservabilityPort` (defined in Application layer)

**Adapter**: `CloudWatchObservability` (Infrastructure layer)

[source,csharp]
----
// Infrastructure/Observability/CloudWatchObservability.cs
public class CloudWatchObservability : IObservabilityPort
{
    private readonly ILogger _logger;
    private readonly IAmazonCloudWatch _cloudWatch;

    public void LogInformation(string message, params object[] args)
    {
        _logger.LogInformation(message, args);
    }

    public void LogError(Exception ex, string message, params object[] args)
    {
        _logger.LogError(ex, message, args);
    }

    public void RecordMetric(string metricName, double value)
    {
        var metricDatum = new MetricDatum
        {
            MetricName = metricName,
            Value = value,
            Unit = StandardUnit.Count,
            TimestampUtc = DateTime.UtcNow
        };

        var request = new PutMetricDataRequest
        {
            Namespace = "LoyaltyService",
            MetricData = new List<MetricDatum> { metricDatum }
        };

        // Fire-and-forget (async without await)
        _ = _cloudWatch.PutMetricDataAsync(request);
    }
}
----

== Database Schema (DynamoDB)

=== RewardTransactions Table

**Table Name**: `LoyaltyService-RewardTransactions`

**Primary Key**:

- **Partition Key**: `TransactionId` (String) - Unique transaction identifier
- **Sort Key**: None (single-item access pattern)

**Global Secondary Indexes**:

. **CustomerIdIndex**:
   - **Partition Key**: `CustomerId` (String)
   - **Sort Key**: `TransactionDate` (String, ISO 8601)
   - **Projection**: ALL
   - **Use Case**: Query customer's reward history

**Attributes**:

[source,json]
----
{
  "TransactionId": "string",          // PK: e.g., "TXN-2025-01-21-ABC123"
  "CustomerId": "string",             // GSI PK: Viva Consumer ID
  "TransactionDate": "string",        // GSI SK: ISO 8601 timestamp
  "PointsEarned": "number",           // Points awarded in this transaction
  "SchemesParticipated": ["string"],  // ["FLYBUYS", "INTERNAL_OTR"]
  "ItemCount": "number",              // Number of items in basket
  "ItemSummary": "string",            // Human-readable summary: "2 items - Fuel, Coffee"
  "SourceTransactionId": "string"     // Reference to POS transaction
}
----

**Capacity**:

- **Provisioned**: On-demand (auto-scaling)
- **Expected Load**: 100K transactions/day (avg 1.2 TPS, peak 10 TPS)
- **Item Size**: ~500 bytes per transaction
- **Storage**: ~1.5 GB/month growth

**Point-in-Time Recovery**: Enabled (35-day retention)

**TTL**: Not configured (retain all transaction history for audit)

== AWS Service Configuration

=== ECS Fargate Deployment

**Cluster**: `LoyaltyService-Production`

**Service**: `LoyaltyService`

**Task Definition**:

[source,yaml]
----
family: LoyaltyService
cpu: 1024              # 1 vCPU
memory: 2048           # 2 GB
networkMode: awsvpc
requiresCompatibilities: [FARGATE]

containerDefinitions:
  - name: loyalty-service
    image: 123456789012.dkr.ecr.ap-southeast-2.amazonaws.com/loyalty-service:latest
    essential: true
    portMappings:
      - containerPort: 8080
        protocol: tcp
    environment:
      - name: ASPNETCORE_ENVIRONMENT
        value: Production
      - name: AWS_REGION
        value: ap-southeast-2
    secrets:
      - name: EagleEye__ApiKey
        valueFrom: arn:aws:secretsmanager:ap-southeast-2:123456789012:secret:loyalty/eagleeye-api-key
      - name: Flybuys__ClientSecret
        valueFrom: arn:aws:secretsmanager:ap-southeast-2:123456789012:secret:loyalty/flybuys-client-secret
    healthCheck:
      command: ["CMD-SHELL", "curl -f http://localhost:8080/health || exit 1"]
      interval: 30
      timeout: 5
      retries: 3
      startPeriod: 60
    logConfiguration:
      logDriver: awslogs
      options:
        awslogs-group: /ecs/LoyaltyService
        awslogs-region: ap-southeast-2
        awslogs-stream-prefix: ecs
----

**Auto Scaling**:

- **Target Metric**: CPU Utilization
- **Target Value**: 70%
- **Min Tasks**: 2
- **Max Tasks**: 10
- **Scale-out Cooldown**: 60 seconds
- **Scale-in Cooldown**: 300 seconds

=== Application Load Balancer

**Type**: Application Load Balancer (ALB)

**Scheme**: Internet-facing

**Target Group**:

- **Protocol**: HTTP
- **Port**: 8080
- **Health Check**: `/health` endpoint
- **Deregistration Delay**: 30 seconds

**Listener Rules**:

. **HTTPS:443**: Forward to LoyaltyService target group
. **HTTP:80**: Redirect to HTTPS

**SSL Certificate**: AWS Certificate Manager (ACM) - `*.api.otr.com.au`

=== API Gateway

**Type**: HTTP API (lower cost, simpler than REST API)

**Integrations**:

- **Backend**: ALB (VPC Link)
- **Base Path**: `/loyalty/v1`

**Authorization**:

- **Type**: JWT Authorizer
- **Issuer**: Microsoft Entra External ID (CIAM)
- **Audience**: `api://loyalty-service`

**Rate Limiting**:

- **Throttle**: 1000 requests/second (burst: 2000)
- **Per-Client Quota**: 10,000 requests/day

**CORS Configuration**:

[source,yaml]
----
allowOrigins:
  - https://app.otr.com.au
  - https://app-staging.otr.com.au
allowMethods:
  - GET
  - POST
  - PUT
  - DELETE
allowHeaders:
  - Authorization
  - Content-Type
maxAge: 3600
----

=== AWS Secrets Manager

**Secrets**:

. **loyalty/eagleeye-api-key**: EagleEye API authentication
. **loyalty/flybuys-client-secret**: Flybuys OAuth client secret
. **loyalty/dynamodb-credentials**: DynamoDB access (if cross-account)
. **loyalty/redis-password**: ElastiCache Redis authentication

**Rotation**:

- **EagleEye API Key**: Manual rotation (vendor-managed)
- **Flybuys Client Secret**: 90-day automatic rotation (Lambda rotator)
- **Redis Password**: Manual rotation (rare)

== Observability

=== CloudWatch Metrics

**Custom Metrics** (Namespace: `LoyaltyService`):

. **Transaction Processing**:
   - `Transaction.Adjudicated` - Count of successful adjudications
   - `Transaction.Failed` - Count of failed adjudications
   - `Transaction.Latency` - P50, P95, P99 latency

. **Points Operations**:
   - `Points.Earned` - Total points earned (sum)
   - `Points.BalanceQuery` - Balance query count
   - `Points.QueryLatency` - Balance query latency

. **Partner Integration**:
   - `Flybuys.ApiCall` - Count of Flybuys API calls
   - `Flybuys.ApiError` - Count of Flybuys errors
   - `EagleEye.ApiCall` - Count of EagleEye API calls
   - `EagleEye.ApiError` - Count of EagleEye errors

. **Cache Performance**:
   - `Cache.Hit` - Cache hit count
   - `Cache.Miss` - Cache miss count
   - `Cache.HitRate` - Calculated hit rate percentage

. **Domain Events**:
   - `DomainEvent.Published` - Count of events published
   - `DomainEvent.Failed` - Count of failed event publishes

**CloudWatch Dashboards**:

. **Transaction Dashboard**: Real-time transaction adjudication metrics
. **Partner Integration Dashboard**: EagleEye and Flybuys API health
. **Cache Performance Dashboard**: Redis hit rates and latency

=== CloudWatch Logs

**Log Groups**:

. `/ecs/LoyaltyService` - Application logs
. `/aws/lambda/LoyaltyService-EventProcessor` - Event processing logs
. `/aws/apigateway/LoyaltyService` - API Gateway access logs

**Log Retention**: 90 days (compliance requirement)

**Log Insights Queries**:

. **Failed Transactions**:
+
[source,sql]
----
fields @timestamp, transactionId, errorMessage
| filter @message like /Transaction adjudication failed/
| sort @timestamp desc
| limit 100
----

. **Slow Queries**:
+
[source,sql]
----
fields @timestamp, operation, duration
| filter duration > 1000
| sort duration desc
| limit 50
----

=== X-Ray Distributed Tracing

**Enabled Services**:

- API Gateway
- ECS Fargate tasks
- DynamoDB
- Lambda functions (event processors)

**Trace Sampling**: 10% of requests (cost optimization)

**Service Map**: Visualizes dependencies between LoyaltyService, EagleEye, Flybuys, ProfileService

== Security

=== WAF (Web Application Firewall)

**Rules**:

. **Rate Limiting**: 100 requests/5 minutes per IP
. **Geographic Restriction**: Allow Australia and New Zealand only
. **Known Bad Inputs**: AWS Managed Rules - Core Rule Set
. **SQL Injection**: AWS Managed Rules - SQL database protection
. **Bot Control**: AWS Managed Rules - Bot Control

=== IAM Roles

**ECS Task Execution Role**:

- Pull Docker images from ECR
- Write logs to CloudWatch Logs
- Read secrets from Secrets Manager

**ECS Task Role**:

- Read/Write DynamoDB `RewardTransactions` table
- Publish events to EventBridge
- Read/Write ElastiCache Redis cluster
- Put metrics to CloudWatch

=== Network Security

**VPC Configuration**:

- **Private Subnets**: ECS Fargate tasks, ElastiCache
- **Public Subnets**: Application Load Balancer
- **NAT Gateway**: Outbound internet access from private subnets

**Security Groups**:

. **ALB Security Group**:
   - Inbound: HTTPS (443) from anywhere
   - Outbound: HTTP (8080) to ECS tasks

. **ECS Task Security Group**:
   - Inbound: HTTP (8080) from ALB
   - Outbound: HTTPS (443) to internet (EagleEye, Flybuys)
   - Outbound: 6379 to ElastiCache

. **ElastiCache Security Group**:
   - Inbound: 6379 from ECS tasks only

== Disaster Recovery

=== Backup Strategy

**DynamoDB**:

- **Point-in-Time Recovery**: Enabled (35-day retention)
- **On-Demand Backups**: Weekly full backup to S3 (90-day retention)
- **Cross-Region Replication**: Disabled (cost optimization, acceptable RPO)

**ElastiCache**:

- **Daily Snapshots**: 4:00 AM AEST
- **Retention**: 7 days
- **Cross-AZ Replication**: Enabled (automatic failover)

=== Recovery Objectives

**RTO (Recovery Time Objective)**: 4 hours

**RPO (Recovery Point Objective)**: 1 hour (acceptable data loss)

**Business Continuity**:

- LoyaltyService is NOT critical for in-store purchases (POS can operate offline)
- Critical for mobile app experience (degraded mode: show cached data)

=== Runbook: Restore from Backup

. **DynamoDB Table Restore**:
+
[source,bash]
----
aws dynamodb restore-table-from-backup \
  --target-table-name LoyaltyService-RewardTransactions \
  --backup-arn arn:aws:dynamodb:ap-southeast-2:123456789012:table/LoyaltyService-RewardTransactions/backup/01234567890123-abcdefgh
----

. **ElastiCache Cluster Restore**:
+
[source,bash]
----
aws elasticache create-cache-cluster \
  --cache-cluster-id loyalty-service-redis-restored \
  --snapshot-name loyalty-service-redis-snapshot-2025-01-21 \
  --cache-node-type cache.r6g.large \
  --engine redis
----

. **Update ECS Service** to point to restored resources (environment variables)

. **Verify Health**: Check `/health` endpoint and CloudWatch metrics

== Cost Optimization

=== Monthly Cost Estimate (Production)

[width="100%",cols="40%,30%,30%",options="header"]
|===
|Service |Configuration |Estimated Monthly Cost (AUD)

|**ECS Fargate**
|2-10 tasks @ 1 vCPU, 2 GB
|$100 - $500

|**DynamoDB**
|On-demand, 100K writes/day
|$50

|**ElastiCache Redis**
|2 shards, cache.r6g.large
|$400

|**Application Load Balancer**
|1 ALB, 100M requests/month
|$30

|**EventBridge**
|1M events/month
|$1

|**CloudWatch**
|Logs (10 GB/month), Metrics, Dashboards
|$50

|**Secrets Manager**
|4 secrets
|$4

|**Data Transfer**
|10 GB/month (EagleEye, Flybuys API calls)
|$10

|**Total**
|
|**$645 - $1,045/month**
|===

**Cost Optimization Strategies**:

. **ElastiCache Sizing**: Largest cost component - consider smaller instance type
. **DynamoDB On-Demand**: Suitable for variable workload (vs provisioned capacity)
. **CloudWatch Logs**: Use Log Insights queries sparingly (cost per GB scanned)
. **X-Ray Sampling**: 10% sampling reduces cost vs 100% tracing

== Deployment Pipeline

**CI/CD Tool**: GitHub Actions

**Pipeline Stages**:

. **Build**: Compile C# code, run unit tests
. **Security Scan**: Snyk vulnerability scanning
. **Docker Build**: Build Docker image, push to ECR
. **Deploy to Staging**: Update ECS service (staging environment)
. **Integration Tests**: Run E2E tests against staging
. **Deploy to Production**: Blue/green deployment via ECS
. **Smoke Tests**: Verify production health checks

**Blue/Green Deployment**:

- Deploy new task definition
- ALB routes 10% traffic to new version (canary)
- Monitor metrics for 15 minutes
- If healthy: route 100% traffic, terminate old tasks
- If unhealthy: rollback to old task definition

== Related Documentation

- **Bounded Context**: xref:../bounded-contexts/loyalty.adoc[Loyalty Bounded Context]
- **Application Layer**: xref:../application-layer/loyalty/use-cases.adoc[Loyalty Use Cases]
- **Domain Definition**: xref:../domains/loyalty.adoc[Loyalty Domain]
- **Clean Architecture**: xref:../patterns/clean_architecture.adoc[Clean Architecture Pattern]
- **External Systems**:
  * xref:../bounded-contexts/external/eagle_eye.adoc[EagleEye]
  * xref:../bounded-contexts/external/flybuys.adoc[Flybuys]

== Document Control

[cols="1,2,2,4"]
|===
|Version |Date |Author |Changes

|0.1
|2025-01-21
|O.Young (Domain Architect, Ecommerce)
|Initial infrastructure documentation - DynamoDB schema, ECS deployment, ACL adapters
|===
