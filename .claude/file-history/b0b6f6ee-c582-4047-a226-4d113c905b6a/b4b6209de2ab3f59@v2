= LoyaltyService - Application Layer Use Cases
:description: Use cases and application services for LoyaltyService
:keywords: use case, application service, loyalty, clean architecture

== Overview

This document describes the **Application Layer** of LoyaltyService following xref:patterns:clean_architecture.adoc[Clean Architecture] principles.

The Application layer contains:

- **Use Cases**: Single application-specific workflows
- **Application Services**: Coordinate domain objects for complex operations
- **DTOs**: Data structures for transferring data between layers
- **Ports**: Interfaces for infrastructure dependencies (Dependency Inversion Principle)

== Architecture Context

[source]
----
Presentation Layer (BFF)
    ↓ calls
Application Layer ← YOU ARE HERE
    ↓ uses
Domain Layer (RewardTransaction aggregate, domain services)
    ↓ depends on abstractions
Infrastructure Layer (EagleEye adapter, repositories, event bus)
----

== Use Cases

=== UC-001: Process Loyalty Transaction

**Actor**: Point-of-Sale (POS) System

**Trigger**: Transaction completed at POS

**Pre-conditions**:
- Customer has valid loyalty membership
- Transaction has been finalized in D365 Commerce

**Post-conditions**:
- RewardTransaction aggregate created with adjudication results
- Points earned/redeemed recorded
- Domain events published (`TransactionAdjudicated`, `PointsEarned`)
- POS notified of rewards applied

==== Use Case Flow

[source]
----
1. POS sends transaction details (customer ID, items, total amount)
2. Application service queries ProfileService for:
   - Customer partner link status (Flybuys linked?)
   - Reward preference (Flybuys points vs OTR fuel discount)
3. Application service calls TransactionAdjudicationService (domain service)
4. Domain service calculates eligible schemes and reward amounts
5. Application service calls EagleEye via ILoyaltyPlatformPort:
   - Submit transaction for adjudication
   - Receive points earned/grants issued
6. Application service creates RewardTransaction aggregate
7. RewardTransaction aggregate applies business rules and publishes domain events
8. Application service persists aggregate via IRewardTransactionRepository
9. Application service publishes events via IEventBusPort
10. Application service returns confirmation to POS
----

==== Implementation

[source,csharp]
----
// Application/UseCases/ProcessLoyaltyTransaction/ProcessLoyaltyTransactionUseCase.cs
public class ProcessLoyaltyTransactionUseCase : IProcessLoyaltyTransactionUseCase
{
    private readonly IRewardTransactionRepository _repository;
    private readonly ILoyaltyPlatformPort _loyaltyPlatform;
    private readonly IProfileServicePort _profileService;
    private readonly IEventBusPort _eventBus;
    private readonly ITransactionAdjudicationService _adjudicationService;

    public async Task<ProcessLoyaltyTransactionOutput> Execute(
        ProcessLoyaltyTransactionInput input)
    {
        // 1. Get customer context from ProfileService
        var customerContext = await _profileService.GetCustomerContext(input.CustomerId);

        // 2. Determine eligible schemes (domain logic)
        var eligibleSchemes = _adjudicationService.DetermineEligibleSchemes(
            customerContext.RewardPreference,
            customerContext.PartnerLinks);

        // 3. Adjudicate transaction via loyalty platform
        var adjudicationResult = await _loyaltyPlatform.AdjudicateTransaction(
            new AdjudicationRequest
            {
                TransactionId = input.TransactionId,
                CustomerId = input.CustomerId,
                Amount = input.Amount,
                Items = input.Items,
                EligibleSchemes = eligibleSchemes
            });

        // 4. Create domain aggregate
        var rewardTransaction = RewardTransaction.Create(
            transactionId: input.TransactionId,
            customerId: input.CustomerId,
            adjudicationResult: adjudicationResult);

        // 5. Persist aggregate
        await _repository.Save(rewardTransaction);

        // 6. Publish domain events
        foreach (var domainEvent in rewardTransaction.GetDomainEvents())
        {
            await _eventBus.Publish(domainEvent);
        }

        // 7. Return output DTO
        return new ProcessLoyaltyTransactionOutput
        {
            TransactionId = rewardTransaction.Id,
            PointsEarned = rewardTransaction.PointsEarned,
            GrantsIssued = rewardTransaction.GrantsIssued.Select(MapToDto).ToList(),
            Status = rewardTransaction.Status
        };
    }
}
----

==== Input DTO

[source,csharp]
----
// Application/UseCases/ProcessLoyaltyTransaction/ProcessLoyaltyTransactionInput.cs
public class ProcessLoyaltyTransactionInput
{
    public string TransactionId { get; set; }
    public string CustomerId { get; set; }
    public decimal Amount { get; set; }
    public List<TransactionItem> Items { get; set; }
    public string StoreId { get; set; }
    public DateTime TransactionTime { get; set; }
}

public class TransactionItem
{
    public string ProductId { get; set; }
    public string ProductName { get; set; }
    public int Quantity { get; set; }
    public decimal UnitPrice { get; set; }
}
----

==== Output DTO

[source,csharp]
----
// Application/UseCases/ProcessLoyaltyTransaction/ProcessLoyaltyTransactionOutput.cs
public class ProcessLoyaltyTransactionOutput
{
    public string TransactionId { get; set; }
    public int PointsEarned { get; set; }
    public List<GrantDto> GrantsIssued { get; set; }
    public TransactionStatus Status { get; set; }
}

public class GrantDto
{
    public string GrantId { get; set; }
    public string GrantType { get; set; }  // "FuelDiscount", "ProductVoucher"
    public decimal Value { get; set; }
    public DateTime ExpiryDate { get; set; }
}
----

==== Application Service Port (Dependency Inversion)

[source,csharp]
----
// Application/Ports/ILoyaltyPlatformPort.cs
// This interface is defined in Application layer but implemented in Infrastructure

public interface ILoyaltyPlatformPort
{
    /// <summary>
    /// Adjudicates a transaction to determine rewards.
    /// </summary>
    /// <remarks>
    /// Infrastructure: Implemented by EagleEyeAdapter in Infrastructure layer.
    /// The adapter translates OTR domain model → EagleEye API model.
    /// </remarks>
    Task<AdjudicationResult> AdjudicateTransaction(AdjudicationRequest request);

    /// <summary>
    /// Queries customer points balance for specified scheme.
    /// </summary>
    Task<PointsBalance> GetPointsBalance(CustomerId customerId, LoyaltyScheme scheme);
}
----

=== UC-002: Link Partner Account

**Actor**: Mobile App User

**Trigger**: Customer selects "Link Flybuys Account" in mobile app

**Pre-conditions**:
- Customer has valid OTR account
- Customer has valid Flybuys account

**Post-conditions**:
- PartnerLink created in ProfileService
- Partner account activated in external partner system (Flybuys)
- Domain event published (`PartnerLinked`)
- Customer can now earn partner rewards

==== Use Case Flow

[source]
----
1. Customer initiates OAuth linking flow in mobile app
2. Customer redirected to Flybuys for authentication
3. Flybuys redirects back with OAuth authorization code
4. Application service exchanges auth code for access token
5. Application service retrieves Flybuys member ID via partner API
6. Application service creates PartnerLink in ProfileService
7. Application service activates link in Flybuys system
8. If activation fails, compensating action: remove PartnerLink
9. Application service publishes PartnerLinked event
10. Application service returns confirmation to mobile app
----

==== Implementation (with Saga Pattern)

[source,csharp]
----
// Application/UseCases/LinkPartnerAccount/LinkPartnerAccountUseCase.cs
public class LinkPartnerAccountUseCase : ILinkPartnerAccountUseCase
{
    private readonly IProfileServicePort _profileService;
    private readonly IPartnerPlatformPort _partnerPlatform;
    private readonly IOAuthServicePort _oauthService;
    private readonly IEventBusPort _eventBus;

    public async Task<LinkPartnerAccountOutput> Execute(LinkPartnerAccountInput input)
    {
        // 1. Exchange OAuth code for tokens
        var oauthTokens = await _oauthService.ExchangeCodeForTokens(
            input.AuthorizationCode,
            input.CodeVerifier);

        // 2. Get partner member ID
        var partnerMemberId = await _partnerPlatform.GetMemberId(oauthTokens.AccessToken);

        // 3. Create partner link (Saga step 1)
        try
        {
            await _profileService.CreatePartnerLink(new CreatePartnerLinkCommand
            {
                CustomerId = input.CustomerId,
                PartnerId = "FLYBUYS",
                PartnerMemberId = partnerMemberId,
                AccessToken = oauthTokens.AccessToken,
                RefreshToken = oauthTokens.RefreshToken
            });
        }
        catch (Exception ex)
        {
            throw new PartnerLinkCreationFailedException("Failed to create partner link", ex);
        }

        // 4. Activate in partner system (Saga step 2)
        try
        {
            await _partnerPlatform.ActivateAccount(
                partnerMemberId,
                new ActivationRequest { OtrCustomerId = input.CustomerId });
        }
        catch (Exception ex)
        {
            // Compensating action: Remove partner link
            await _profileService.RemovePartnerLink(input.CustomerId, "FLYBUYS");
            throw new PartnerActivationFailedException(
                "Failed to activate partner account. Link has been removed.", ex);
        }

        // 5. Publish domain event
        await _eventBus.Publish(new PartnerLinkedEvent
        {
            CustomerId = input.CustomerId,
            PartnerId = "FLYBUYS",
            PartnerMemberId = partnerMemberId,
            LinkedAt = DateTime.UtcNow
        });

        // 6. Return confirmation
        return new LinkPartnerAccountOutput
        {
            LinkId = $"{input.CustomerId}-FLYBUYS",
            Status = "Active",
            LinkedAt = DateTime.UtcNow
        };
    }
}
----

=== UC-003: Query Points Balance

**Actor**: Mobile App User

**Trigger**: Customer views "My Rewards" screen

**Pre-conditions**:
- Customer has valid loyalty membership

**Post-conditions**:
- Points balance returned to mobile app
- (Optional) Balance cached for performance

==== Use Case Flow

[source]
----
1. Mobile app requests points balance for customer
2. Application service checks cache for recent balance
3. If cache miss or stale:
   a. Application service calls EagleEye via ILoyaltyPlatformPort
   b. Application service caches result with 5-minute TTL
4. Application service returns balance to mobile app
----

==== Implementation (CQRS Query)

[source,csharp]
----
// Application/Queries/GetPointsBalanceQuery.cs
public class GetPointsBalanceQuery : IGetPointsBalanceQuery
{
    private readonly ILoyaltyPlatformPort _loyaltyPlatform;
    private readonly ICachePort _cache;
    private readonly IProfileServicePort _profileService;

    public async Task<PointsBalanceDto> Execute(CustomerId customerId)
    {
        // 1. Check cache
        var cacheKey = $"points:balance:{customerId}";
        var cachedBalance = await _cache.Get<PointsBalanceDto>(cacheKey);

        if (cachedBalance != null)
        {
            return cachedBalance;
        }

        // 2. Get customer's reward preference to determine which balance to show
        var customerContext = await _profileService.GetCustomerContext(customerId);

        // 3. Query loyalty platform for balance
        var balance = await _loyaltyPlatform.GetPointsBalance(
            customerId,
            customerContext.RewardPreference.PreferredScheme);

        // 4. Map to DTO
        var balanceDto = new PointsBalanceDto
        {
            CustomerId = customerId.Value,
            Scheme = balance.Scheme.ToString(),
            AvailablePoints = balance.AvailablePoints,
            PendingPoints = balance.PendingPoints,
            TotalPoints = balance.TotalPoints,
            AsOfDate = DateTime.UtcNow
        };

        // 5. Cache result
        await _cache.Set(cacheKey, balanceDto, TimeSpan.FromMinutes(5));

        return balanceDto;
    }
}
----

== Application Services

Application services coordinate multiple use cases or domain services for complex workflows.

=== LoyaltyApplicationService

[source,csharp]
----
// Application/Services/LoyaltyApplicationService.cs
public class LoyaltyApplicationService
{
    private readonly IProcessLoyaltyTransactionUseCase _processTransaction;
    private readonly IGetPointsBalanceQuery _getPointsBalance;
    private readonly ILinkPartnerAccountUseCase _linkPartner;

    /// <summary>
    /// Get complete customer loyalty summary (for mobile dashboard).
    /// Aggregates data from multiple queries.
    /// </summary>
    public async Task<CustomerLoyaltySummary> GetCustomerLoyaltySummary(CustomerId customerId)
    {
        // Parallel queries for performance
        var (pointsBalance, recentTransactions, activeGrants) = await Task.WhenAll(
            _getPointsBalance.Execute(customerId),
            _getRecentTransactions.Execute(customerId, limit: 5),
            _getActiveGrants.Execute(customerId)
        );

        return new CustomerLoyaltySummary
        {
            CustomerId = customerId.Value,
            PointsBalance = pointsBalance,
            RecentTransactions = recentTransactions,
            ActiveGrants = activeGrants,
            NextTier = await CalculateNextTier(pointsBalance)
        };
    }

    /// <summary>
    /// Process transaction and notify customer (combines multiple use cases).
    /// </summary>
    public async Task<ProcessAndNotifyResult> ProcessTransactionAndNotify(
        ProcessLoyaltyTransactionInput input)
    {
        // 1. Process transaction
        var result = await _processTransaction.Execute(input);

        // 2. If points earned, trigger notification workflow
        if (result.PointsEarned > 0)
        {
            await _notificationService.SendPointsEarnedNotification(
                input.CustomerId,
                result.PointsEarned);
        }

        return new ProcessAndNotifyResult
        {
            TransactionResult = result,
            NotificationSent = result.PointsEarned > 0
        };
    }
}
----

== Application Ports (Dependency Inversion)

All external dependencies accessed through ports (interfaces):

=== Infrastructure Ports

[source,csharp]
----
// Application/Ports/IRewardTransactionRepository.cs
public interface IRewardTransactionRepository
{
    Task Save(RewardTransaction transaction);
    Task<RewardTransaction> FindById(TransactionId id);
    Task<List<RewardTransaction>> FindByCustomerId(CustomerId customerId, int limit);
}

// Application/Ports/IEventBusPort.cs
public interface IEventBusPort
{
    Task Publish<TEvent>(TEvent domainEvent) where TEvent : IDomainEvent;
}

// Application/Ports/ICachePort.cs
public interface ICachePort
{
    Task<T> Get<T>(string key);
    Task Set<T>(string key, T value, TimeSpan ttl);
    Task Remove(string key);
}
----

=== External Service Ports

[source,csharp]
----
// Application/Ports/IProfileServicePort.cs
// Abstraction for ProfileService (another bounded context)
public interface IProfileServicePort
{
    Task<CustomerContext> GetCustomerContext(CustomerId customerId);
    Task CreatePartnerLink(CreatePartnerLinkCommand command);
    Task RemovePartnerLink(CustomerId customerId, string partnerId);
}

// Application/Ports/IPartnerPlatformPort.cs
// Abstraction for external partner systems (Flybuys)
public interface IPartnerPlatformPort
{
    Task<string> GetMemberId(string accessToken);
    Task ActivateAccount(string memberId, ActivationRequest request);
    Task DeactivateAccount(string memberId);
}
----

== Testing Application Layer

=== Unit Test (Use Case with Mocks)

[source,csharp]
----
[TestFixture]
public class ProcessLoyaltyTransactionUseCaseTests
{
    [Test]
    public async Task Execute_Should_CreateRewardTransaction_WhenAdjudicationSucceeds()
    {
        // Arrange
        var mockRepository = new Mock<IRewardTransactionRepository>();
        var mockLoyaltyPlatform = new Mock<ILoyaltyPlatformPort>();
        var mockProfileService = new Mock<IProfileServicePort>();
        var mockEventBus = new Mock<IEventBusPort>();
        var mockAdjudicationService = new Mock<ITransactionAdjudicationService>();

        mockProfileService
            .Setup(x => x.GetCustomerContext(It.IsAny<CustomerId>()))
            .ReturnsAsync(new CustomerContext
            {
                RewardPreference = RewardPreference.Flybuys,
                PartnerLinks = new List<PartnerLink> { FlybuysLink }
            });

        mockLoyaltyPlatform
            .Setup(x => x.AdjudicateTransaction(It.IsAny<AdjudicationRequest>()))
            .ReturnsAsync(new AdjudicationResult
            {
                PointsEarned = 150,
                Scheme = LoyaltyScheme.Flybuys
            });

        var useCase = new ProcessLoyaltyTransactionUseCase(
            mockRepository.Object,
            mockLoyaltyPlatform.Object,
            mockProfileService.Object,
            mockEventBus.Object,
            mockAdjudicationService.Object);

        var input = new ProcessLoyaltyTransactionInput
        {
            TransactionId = "TXN-001",
            CustomerId = "CUST-123",
            Amount = 150.00m
        };

        // Act
        var result = await useCase.Execute(input);

        // Assert
        Assert.That(result.PointsEarned, Is.EqualTo(150));
        mockRepository.Verify(x => x.Save(It.IsAny<RewardTransaction>()), Times.Once);
        mockEventBus.Verify(
            x => x.Publish(It.IsAny<TransactionAdjudicatedEvent>()),
            Times.Once);
    }
}
----

=== Integration Test (With In-Memory Infrastructure)

[source,csharp]
----
[TestFixture]
public class ProcessLoyaltyTransactionIntegrationTests
{
    [Test]
    public async Task Execute_Should_PublishEventsToEventBus()
    {
        // Arrange - In-memory implementations
        var inMemoryRepository = new InMemoryRewardTransactionRepository();
        var inMemoryEventBus = new InMemoryEventBus();
        var fakeLoyaltyPlatform = new FakeLoyaltyPlatform();
        var fakeProfileService = new FakeProfileService();
        var realAdjudicationService = new TransactionAdjudicationService();

        var useCase = new ProcessLoyaltyTransactionUseCase(
            inMemoryRepository,
            fakeLoyaltyPlatform,
            fakeProfileService,
            inMemoryEventBus,
            realAdjudicationService);

        // Act
        await useCase.Execute(new ProcessLoyaltyTransactionInput { ... });

        // Assert
        var publishedEvents = inMemoryEventBus.GetPublishedEvents();
        Assert.That(publishedEvents, Has.One.TypeOf<TransactionAdjudicatedEvent>());
        Assert.That(publishedEvents, Has.One.TypeOf<PointsEarnedEvent>());

        var savedTransaction = await inMemoryRepository.FindById("TXN-001");
        Assert.That(savedTransaction, Is.Not.Null);
        Assert.That(savedTransaction.Status, Is.EqualTo(TransactionStatus.Completed));
    }
}
----

== References

- xref:patterns:clean_architecture.adoc[Clean Architecture]
- xref:patterns:backend_for_frontend.adoc[Backend-for-Frontend Pattern]
- xref:../bounded_context/loyalty.adoc[Loyalty Bounded Context]
- Robert C. Martin, *Clean Architecture: A Craftsman's Guide to Software Structure and Design*, Prentice Hall, 2017
