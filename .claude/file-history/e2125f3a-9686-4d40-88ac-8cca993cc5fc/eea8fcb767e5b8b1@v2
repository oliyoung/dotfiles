= Architecture Definition Template
:document-type: Architecture Definition Document
:domain: [Link to Domain]
:status: [Discovery | In Progress | Completed | Approved | Deprecated]
:target-delivery: [Target Delivery Name or Date]
:programme-lead: [Email Address]
:domain-architect: [Email Address]
:business-owner: [Email Address]
:architectural-change: What is asked of the ARB (e.g., review and approve target architecture, provide feedback on risks, etc.)
:solution-architecture: [Link to this document or related solution architecture]
:business-requirements: [Link to business requirements document]
:toc:
:toclevels: 3

== Introduction & Vision

[NOTE]
====
*Instructions*: This template is for *Architecture Review Board (ARB) presentations*. Focus on technical architecture decisions that respond to business requirements. The business case, ROI, and product strategy should be defined by BA/PM in separate documents. Remove all instructional text before submitting to ARB.
====

// 2-4 sentences describing the technical solution at a high level. What architecture are we building and why is this the right technical approach? Include key bounded contexts, integration patterns, and strategic capabilities being established.

[Describe the target state architecture, key bounded contexts introduced/modified, primary integration patterns applied, and foundational capabilities established for future initiatives.]

=== Functional Requirements

[cols="1,5"]
|===
|ID |Description

|BR-001
|[Business requirement that drives architecture - e.g., "All mobile app users must have profiles"]

|BR-002
|[Business requirement 2]

|BR-003
|[Business requirement 3]
|===

== Business Architecture

=== Stakeholder Analysis

[cols="1,1,1,1,2,1"]
|===
|Stakeholder |Role |Interest Level |Influence Level |Engagement Strategy |Communication Frequency

|[Name/Role]
|Business Owner
|High
|High
|Fortnightly steering, requirements sign-off
|Fortnightly

|[Name/Role]
|Technical Lead
|High
|High
|Daily collaboration
|As needed

|[Name/Role]
|Programme Lead
|High
|Medium
|Weekly status updates, escalation point
|Weekly

|End Users (count)
|End Users
|High
|Low
|Beta testing, feedback surveys
|As needed

|[External Partner]
|External Partner
|Medium
|Medium
|Monthly coordination, API support
|Monthly

|[Platform Team]
|Infrastructure
|Low
|High
|Deployment planning, capacity planning
|Fortnightly
|===

=== Baseline Architecture

==== Business Capability

[cols="1,1,1,1,2,1"]
|===
|L1 Domain |L2 Subdomain |L3 Capability |Owned By |Supporting Systems |Maturity Level

|[Domain Name]
|[Subdomain]
|[Capability Name]
|[Team Name]
|[Current Systems]
|[Initial/Defined/Managed/Optimized]

|[Domain Name]
|[Subdomain]
|[Capability Name]
|[Team Name]
|[Current Systems]
|[Maturity Level]
|===

==== Value Stream

===== [Value Stream Name - e.g., "Customer Redeems Fuel Discount"]

[cols="1,2,1,1,2,2"]
|===
|Actor |Activity |System |Duration |Value Added |Pain Points / Waste

|[Actor Name]
|[Activity description]
|[System Name]
|[Duration]
|[Value delivered]
|[Delays, manual work, errors]

|[Actor Name]
|[Activity description]
|[System Name]
|[Duration]
|[Value delivered]
|[Delays, manual work, errors]
|===

==== Pain Points

[cols="1,2,2,1"]
|===
|Category |Pain Point |Business Impact |Frequency

|Customer Experience
|[Pain point description]
|[How it impacts business]
|Daily

|System Resilience
|[Pain point description]
|[How it impacts business]
|Weekly

|Integration
|[Pain point description]
|[How it impacts business]
|Continuous

|Compliance
|[Pain point description]
|[How it impacts business]
|As needed
|===

=== Target State Architecture

==== Business Capability

[cols="1,1,2,1,2"]
|===
|L1 Domain |L2 Subdomain |L3 Capability |Owned By |Supporting Systems

|[Domain Name]
|[Subdomain]
|[New/Enhanced Capability]
|[Team Name]
|[New Bounded Contexts/Systems]

|[Domain Name]
|[Subdomain]
|[New/Enhanced Capability]
|[Team Name]
|[New Bounded Contexts/Systems]
|===

==== Value Stream

===== [Value Stream Name - TO-BE]

[cols="1,2,1,1,2,2"]
|===
|Actor |Activity |System |Duration |Value Added |Pain Points / Waste

|[Actor Name]
|[Activity description]
|[New System/BC]
|[Duration]
|[Value delivered]
|[Remaining pain points, if any]

|[Actor Name]
|[Activity description]
|[New System/BC]
|[Duration]
|[Value delivered]
|[None]
|===

=== Gap Analysis

==== Business Capability Gaps

[cols="2,1,1,2,1,1"]
|===
|Capability |AS-IS State |TO-BE State |Gap Description |Priority |Effort

|[Capability Name]
|[Current state]
|[Target state]
|[What needs to be built/changed]
|High
|Medium

|[Capability Name]
|[Current state]
|[Target state]
|[What needs to be built/changed]
|Medium
|High
|===

==== Value Stream Transformation

[cols="2,1,1,1,2"]
|===
|Metric |AS-IS (Baseline) |TO-BE (Target) |Gap |Business Value

|End-to-End Cycle Time
|[Duration]
|[Duration]
|[Improvement]
|[Value delivered]

|Process Success Rate
|[Percentage]
|[Percentage]
|[Improvement]
|[Reduced errors/rework]

|Customer Completion Rate
|[Percentage]
|[Percentage]
|[Improvement]
|[Higher adoption/revenue]

|Process Duration
|[Duration]
|[Duration]
|[Improvement]
|[Better customer experience]

|Real-Time Data Accuracy
|[N/A or Percentage]
|[Percentage]
|[New capability]
|[Transparency, trust]

|Manual FTE Effort
|[FTE count]
|[FTE count]
|[Reduction]
|[Cost savings]

|Data Entry Error Rate
|[Percentage]
|[Percentage]
|[Improvement]
|[Data quality, compliance]
|===

==== Technology Transformation Requirements

[cols="1,2,2,2,2"]
|===
|Technology Domain |AS-IS Technology |TO-BE Technology |Transformation Needed |Dependency / Risk

|Backend Services
|[Current technology]
|[New architecture/technology]
|[What needs to be done]
|[Risks and dependencies]

|Integration Layer
|[Current technology]
|[New architecture/technology]
|[What needs to be done]
|[Risks and dependencies]

|Authentication
|[Current technology]
|[New architecture/technology]
|[What needs to be done]
|[Risks and dependencies]

|Data Storage
|[Current technology]
|[New architecture/technology]
|[What needs to be done]
|[Risks and dependencies]
|===

== Technical Architecture

=== Technical Capability Requirements

[cols="1,2,4"]
|===
|ID |Capability |Description

|TC-001
|[Capability Name - e.g., "Event-Driven Integration"]
|[Detailed description of what this technical capability enables]

|TC-002
|[Capability Name]
|[Detailed description]

|TC-003
|[Capability Name]
|[Detailed description]
|===

=== Requirements Traceability

[cols="1,1,2,2"]
|===
|Business Requirement |Technical Capability |Implementation |Location

|BR-001, BR-002
|TC-001
|[How these requirements are implemented]
|[Bounded Context or System]

|BR-003
|TC-002
|[How this requirement is implemented]
|[Bounded Context or System]
|===

=== Service Catalogues

// Optional section: List application portfolio, services, and their responsibilities

[cols="2,1,3,2"]
|===
|Service Name |Type |Responsibility |Technology Stack

|[BoundedContextName]
|Domain Service
|[What business capability it supports]
|[Tech stack]

|[ServiceName]
|Infrastructure Service
|[What infrastructure capability it provides]
|[Tech stack]
|===

== Current State Architecture

=== Existing Bounded Contexts

// What bounded contexts exist today?

==== [BoundedContextName]

* *Responsibility*: [What this context does]
* *Technology Stack*: [Languages, frameworks, databases]
* *Integration Points*: [How it integrates with other contexts]
* *Limitations*: [What it cannot do that we now need]

==== [BoundedContextName]

* *Responsibility*: [What this context does]
* *Technology Stack*: [Languages, frameworks, databases]
* *Integration Points*: [How it integrates with other contexts]
* *Limitations*: [What it cannot do that we now need]

=== Current Integration Patterns

// How do contexts currently integrate?

----
[ContextA] --[REST API]--> [ContextB]
[ContextC] --[Event Bus]--> [ContextD]
[ContextE] --[Shared Database]--> [ContextF]  <!-- Technical debt -->
----

*Integration Assessment*:

* *Strengths*: [What works well in current integration approach]
* *Weaknesses*: [What creates coupling or fragility]

=== Technical Debt

// Be honest about existing problems that complicate this initiative

[cols="2,2,2"]
|===
|Debt Item |Impact on This Initiative |Remediation Approach

|[Technical debt description]
|[How it constrains architecture]
|[How we'll address it or work around it]

|[Technical debt description]
|[How it constrains architecture]
|[How we'll address it or work around it]
|===

=== Gap Analysis

*Missing Bounded Contexts*:

* [BoundedContextName]: [Why it's needed]
* [BoundedContextName]: [Why it's needed]

*Missing Integration Capabilities*:

* [Capability]: [Why it's needed]
* [Capability]: [Why it's needed]

*Technology Gaps*:

* [Technology/Platform]: [Why it's needed]
* [Technology/Platform]: [Why it's needed]

== Target State Architecture

=== Bounded Context Model

// Show the strategic design: what bounded contexts exist and how they relate

----
┌─────────────────┐         ┌─────────────────┐
│  [Context A]    │────────▶│  [Context B]    │
│  (New)          │  ACL    │  (Existing)     │
└─────────────────┘         └─────────────────┘
        │                            │
        │ Event                      │ Event
        ▼                            ▼
┌─────────────────────────────────────────────┐
│           Event Bus (SNS/Kinesis)           │
└─────────────────────────────────────────────┘
        │                            │
        │                            ▼
        │                   ┌─────────────────┐
        └──────────────────▶│  [Context C]    │
                            │  (Modified)     │
                            └─────────────────┘
----

*Context Map Legend*:

* `[U,OHS]` - Upstream, Open Host Service
* `[D,CF]` - Downstream, Conformist
* `[D,ACL]` - Downstream, Anti-Corruption Layer
* `[SK]` - Shared Kernel
* `[P]` - Partnership

=== Bounded Context Definitions

==== [BoundedContextName] (New)

===== Responsibility

[Single sentence describing what this context owns]

// Use table format to clearly distinguish what this bounded context owns, orchestrates, and does NOT own

[cols="1,5"]
|===
|Relationship |Responsibility

|Owns
|[Aggregate name]: [What data/state this bounded context is the system of record for]

|Owns
|[Process/Logic]: [What business logic or workflow this bounded context owns]

|Orchestrates
|[External API/Service]: [What external systems this bounded context coordinates without owning]

|Does NOT Own
|[Data/State]: [What this bounded context explicitly does NOT own - owned by other contexts]
|===

===== Core Aggregates

[cols="1,2,1,3"]
|===
|Aggregate Name |Description |Identifier |Properties

|AggregateName
|What business invariants it enforces
|`AggregateId`
|`Property1`, `Property2`, `Property3` (list key properties)

|AggregateName
|What business invariants it enforces
|`AggregateId`
|`Property1`, `Property2`, `Property3`
|===

===== Invariants

* [Invariant 1: business rule that must always be true for the aggregate - e.g., "Transaction results are immutable"]
* [Invariant 2: business rule enforced by aggregate]

===== Domain Events

[cols="1,3"]
|===
|Event Name |Description

|`EventName`
|When published and why (e.g., after which action)

|`EventName`
|When published and why
|===

===== Domain Services

[cols="1,4"]
|===
|Service Name |Responsibility

|`IServiceName`
|What orchestration or domain logic this service performs

|`IServiceName`
|What it does
|===

===== Domain Feature Flags

[cols="1,3"]
|===
|Feature Flag Name |Purpose

|`FeatureFlagName`
|What capability this controls (enable/disable)

|`FeatureFlagName`
|What it controls
|===

===== Dependencies

// Use "External Dependencies" or "Internal Dependencies" subsection if needed for clarity

[cols="1,2,1,1,2"]
|===
|Dependency Name |Integration Pattern |Direction |Type |Purpose

|[DependencyName]
|ACL/Conformist/OHS/Customer-Supplier
|Upstream
|REST API
|Why we call it / what data we need

|[DependencyName]
|ACL/Conformist/OHS/Customer-Supplier
|Downstream
|Event Bus
|Why it calls us / what events we publish
|===

==== [BoundedContextName] (Modified)

===== Current Responsibility

[What it does today]

===== Extended Responsibility

[What new capability added]

===== New Aggregates

[cols="1,2,1,2"]
|===
|Aggregate Name |Description |Identifier |Properties

|AggregateName
|What business invariants it enforces
|
|

|AggregateName
|What business invariants it enforces
|
|
|===

===== New Domain Events

[cols="1,3"]
|===
|Event Name |Description

|EventName
|When published and why

|EventName
|When published and why
|===

===== New Domain Feature Flags

[cols="1,3"]
|===
|Feature Flag Name |Purpose

|FeatureFlagName
|What it controls

|FeatureFlagName
|What it controls
|===

===== Technology Changes

[Any stack changes needed]

*Integration Pattern Changes*: [How integration evolves]

==== [BoundedContextName] (Existing - No Changes)

*Responsibility*: [What it does]

*Integration Points*: [How it's used by new/modified contexts]

=== Integration Architecture

==== System of Record Boundaries

// Clearly document which system owns which data to avoid confusion and duplication

[cols="2,1,4"]
|===
|System Name |Type |System of Record For

|[System/BC Name]
|Infrastructure
|[What data this system is authoritative for - e.g., "OAuth tokens, refresh tokens"]

|[External System Name]
|External System
|[What data this external system owns - e.g., "Customer profile, email, phone"]

|[BoundedContext Name]
|Domain Service
|[What domain data this bounded context owns]
|===

==== Pattern 1: [Pattern Name - e.g., "Event-Driven Internal Integration"]

===== Context Relationship

`[DownstreamContext] [D,CF] <- [U,OHS,PL] [UpstreamContext]`

===== Rationale

// Why this pattern over alternatives?

* [Reason 1 - e.g., "Loose coupling enables independent deployment"]
* [Reason 2 - e.g., "Event bus provides durability and replay"]
* [Reason 3 - e.g., "Published Language ensures contract stability"]

===== Technology Stack

* *Event Bus*: [Azure Event Hub / AWS Kinesis / Kafka] - [Why this choice]
* *Event Schema*: [JSON / Avro / Protobuf] - [Why this choice]
* *Serialization*: [CloudEvents / Custom] - [Why this choice]

===== Key Events

[cols="1,1,1"]
|===
|Event Name |Published By |Consumed By

|
|
|
|===

===== Published Language

====== EventName

[source,json]
----
{
  "eventVersion": "1.0",
  "eventType": "EventName",
  "source": "/[UpstreamContext]/[Aggregate]",
  "eventId": "[GUID]",
  "eventTime": "[ISO8601 Timestamp]",
  "data": {
    "[Property1]": "[Type]",
    "[Property2]": "[Type]"
  }
}
----

===== Consequences

* ✅ [Benefit 1]
* ✅ [Benefit 2]
* ⚠️ [Trade-off 1]
* ⚠️ [Trade-off 2]

==== Pattern 2: [Pattern Name - e.g., "Anti-Corruption Layer for External System"]

*Context Relationship*: `[InternalContext] [D,ACL] <- [U] [ExternalSystem]`

*Rationale*:

* [Why ACL needed - e.g., "External system API unstable, protects domain model"]
* [Why this specific implementation]

*Technology*:

* *API Protocol*: [REST / GraphQL / gRPC] - [Why this choice]
* *ACL Implementation*: [Adapter pattern / Facade / Translation layer]
* *Resilience*: [Circuit breaker / Retry policy / Fallback strategy]

*Translation Strategy*:

* [External concept] → [Domain concept]
* [External concept] → [Domain concept]

*Consequences*:

* ✅ [Benefit - e.g., "Domain model isolated from external changes"]
* ⚠️ [Trade-off - e.g., "Additional translation layer maintenance"]

==== Pattern 3: [Pattern Name]

// Repeat for each major integration pattern

==== Key Integration Flows

// Optional: Include sequence diagrams for critical integration flows using Mermaid syntax

===== [Flow Name - e.g., "Customer Links Partner Account"]

[mermaid]
----
sequenceDiagram
    actor Customer
    participant MobileApp
    participant BoundedContext1
    participant BoundedContext2
    participant ExternalSystem

    Customer->>MobileApp: [Action]
    MobileApp->>BoundedContext1: [API Call]
    BoundedContext1->>ExternalSystem: [External API Call]
    ExternalSystem-->>BoundedContext1: [Response]
    BoundedContext1-->>MobileApp: [Response]
----

==== Domain Service Interfaces

// Optional: Document key domain service interfaces that implement integration patterns

*[BoundedContextName] Domain Layer*

[source,csharp]
----
public interface I[ServiceName]
{
    Task<[ReturnType]> [MethodName]([Parameters]);
}
----

*[External System] Infrastructure Implementation*

[source,csharp]
----
public class [ImplementationName] : I[ServiceName]
{
    // Conformist/ACL implementation - [pattern used]
}
----

==== Integration Details

// Optional: Technical details for complex integrations

*Technology Stack*

* [Technology choice 1]: [Why chosen]
* [Technology choice 2]: [Why chosen]

*Performance Requirements*

* [Operation]: [Target latency/throughput]
* [Operation]: [Target latency/throughput]

*Error Handling*

* [Error scenario]: [How handled]
* [Error scenario]: [How handled]

=== Data Architecture Principles

*Bounded Context Data Ownership*:

* Each bounded context owns its data (no shared databases)
* Aggregates are transaction boundaries (ACID within, eventual consistency across)
* Read models may denormalize across aggregates (CQRS where appropriate)

*Database per Bounded Context*:

[cols="2,2,3"]
|===
|Bounded Context |Database Technology |Rationale

|[ContextName]
|[PostgreSQL / Cosmos DB / DynamoDB]
|[Why this choice for this context]

|[ContextName]
|[PostgreSQL / Cosmos DB / DynamoDB]
|[Why this choice for this context]
|===

*Data Migration Strategy*:

// How do we migrate data from legacy systems to new bounded contexts?

* [Migration approach for DataSet1]
* [Migration approach for DataSet2]
* [Coexistence strategy during migration]

=== Technology Choices

==== Technology Stack Summary

[cols="2,2,3"]
|===
|Category |Technology Choice |Rationale

|*Backend Framework*
|[.NET Core / Spring Boot / Node.js]
|[Why chosen for this initiative]

|*Event Bus*
|[Azure Event Hub / AWS Kinesis / Kafka]
|[Why chosen]

|*Databases*
|[See Database per Context table above]
|[Overall data strategy]

|*API Gateway*
|[Azure API Management / AWS API Gateway]
|[Why chosen]

|*Authentication*
|[Azure Entra ID / Auth0 / Cognito]
|[Why chosen]

|*Monitoring*
|[Application Insights / CloudWatch / Datadog]
|[Why chosen]

|*CI/CD*
|[Azure DevOps / GitHub Actions / GitLab CI]
|[Why chosen]
|===

==== Technology Constraints

*Must Use* (Platform Standards):

* [Technology 1]: [Why it's mandatory - e.g., "OTR platform standard"]
* [Technology 2]: [Why it's mandatory]

*Must Avoid*:

* [Technology 1]: [Why it's prohibited - e.g., "End of life, security concerns"]
* [Technology 2]: [Why it's prohibited]

== Architecture Decisions

// Two format options: Use table format for concise decision log, or traditional ADR format for detailed rationale. Choose based on ARB preference and decision complexity.

=== Option 1: Table Format (Concise)

[cols="1,2,1,2,2,2,2,2"]
|===
|ADR |Decision |Status |Context |Decision |Rationale |Alternatives Considered |Consequences

|ADR-001
|[Decision Title - e.g., "Aggregate Ownership"]
|Accepted
|[What problem? - e.g., "Could belong to BC1 or BC2"]
|[What decided - e.g., "BC1 owns aggregate"]
|[Why - key reasons]
|[Alternative rejected and why]
|*Positive*: [Benefits] +
*Negative*: [Trade-offs]

|ADR-002
|[Decision Title]
|Proposed
|[Context]
|[Decision]
|[Rationale]
|[Alternatives]
|[Consequences]
|===

=== Option 2: Traditional ADR Format (Detailed)

==== ADR-001: [Decision Title - e.g., "Bounded Context Ownership of [AggregateName]"]

*Status*: Proposed | Accepted | Deprecated | Superseded

*Context*:

// What problem required a decision? What are the forces at play?

[Describe the architectural problem that needs to be solved. What are the conflicting concerns?]

*Decision*:

// What did we decide? Be specific and unambiguous.

[State the decision clearly in one sentence, then elaborate if needed.]

*Rationale*:

// Why is this the right decision?

* [Reason 1 - architectural principle or quality attribute]
* [Reason 2 - alignment with domain model]
* [Reason 3 - technical feasibility or risk mitigation]

*Alternatives Considered*:

*Alternative 1: [Name]*

* *Description*: [What this alternative would look like]
* *Pros*: [Benefits of this approach]
* *Cons*: [Why rejected]

*Alternative 2: [Name]*

* *Description*: [What this alternative would look like]
* *Pros*: [Benefits of this approach]
* *Cons*: [Why rejected]

*Consequences*:

*Positive*:

* [Benefit 1]
* [Benefit 2]

*Negative* (Trade-offs):

* [Trade-off 1 - what we sacrifice]
* [Trade-off 2 - what complexity we accept]

*Neutral*:

* [Impact 1 - neither good nor bad, just different]

==== ADR-002: [Decision Title - e.g., "Integration Pattern for [ExternalSystem]"]

// Repeat ADR structure for each significant architectural decision

*Key ADRs to Document*:

* Bounded context boundaries and ownership
* Integration pattern choices (ACL vs Conformist vs OHS)
* Technology stack selections
* Data ownership and database choices
* Event schema design (Published Language)
* Security and authentication approach
* Deployment and hosting strategy

== Migration Strategy

=== Phased Approach

// How do we get from current state to target state?

==== Phase 1: [Phase Name] ([Technical Milestone])

*Objective*: [What architectural capability this phase establishes]

*Bounded Context Deliverables*:

* [BoundedContextName]: [What gets built - aggregates, services, repositories]
* [BoundedContextName]: [What gets built]

*Integration Deliverables*:

* [Integration pattern implemented]
* [Event schemas defined and published]
* [ACL adapters implemented]

*Data Migration*:

* [What data gets migrated in this phase]
* [Coexistence strategy with legacy]

*Technical Success Criteria*:

* [Measurable technical criterion - e.g., "ProfileService API operational with < 200ms p95 latency"]
* [Measurable technical criterion - e.g., "All legacy users migrated to new VivaConsumerId"]

==== Phase 2: [Phase Name] ([Technical Milestone])

// Repeat for each phase

=== Coexistence Strategy

// How do new and legacy systems coexist during migration?

*Dual-Write Pattern*:

* [Where we write to both legacy and new systems]
* [How we ensure consistency]

*Strangler Fig Pattern*:

* [What legacy functionality gets replaced incrementally]
* [How we route traffic between legacy and new]

*Parallel Run*:

* [Where we run both systems in parallel for validation]
* [Success criteria for cutover]

=== Rollback Strategy

// If something goes wrong, how do we revert?

*Rollback Triggers*:

* [Criterion 1 - e.g., "Error rate > 5%"]
* [Criterion 2 - e.g., "Latency degradation > 2x baseline"]

*Rollback Procedure*:

. [Step 1 - e.g., "Revert API Gateway routing to legacy"]
. [Step 2 - e.g., "Disable new bounded context feature flags"]
. [Step 3 - e.g., "Reconcile data inconsistencies"]

== Assumptions

// Document critical assumptions that underpin the architecture. If these assumptions prove false, the architecture may need significant revision.

[cols="1,4,3,2"]
|===
|ID |Assumption |Impact if False |Validation Approach

|ASM-01
|[Assumption - e.g., "Event Bus infrastructure will support 10k events/day"]
|[Impact - e.g., "Domain events delayed or dropped; eventual consistency breaks"]
|[How to validate - e.g., "Load testing"]

|ASM-02
|[Assumption]
|[Impact if false]
|[Validation approach]
|===

== Constraints

// Document constraints that limit architectural choices. Unlike assumptions, constraints are known facts that cannot be changed.

[cols="1,1,3,3"]
|===
|ID |Constraint Type |Description |Architectural Impact

|CON-001
|Regulatory
|[Constraint - e.g., "Must comply with Australian Privacy Principles (APP)"]
|[Impact - e.g., "OAuth flow requires explicit consent; audit logging"]

|CON-002
|Commercial
|[Constraint - e.g., "Cannot modify external system API contracts"]
|[Impact - e.g., "Must use Conformist pattern"]

|CON-003
|Security
|[Constraint - e.g., "OAuth tokens must be encrypted at rest"]
|[Impact - e.g., "Tokens stored in separate OAuth Service with encryption"]

|CON-004
|Operational
|[Constraint - e.g., "Phased rollout required (no big-bang deployment)"]
|[Impact - e.g., "Strangler Fig pattern; 6-month migration timeline"]

|CON-005
|Technical
|[Constraint - e.g., "Must use existing Azure/AWS infrastructure"]
|[Impact - e.g., "Technology selection constrained to platform services"]
|===

== Technical Risks and Constraints

=== Risk 1: [Risk Name - e.g., "External System API Instability"]

*Impact*: High | Medium | Low +
*Probability*: High | Medium | Low +
*Risk Score*: [Impact × Probability]

*Description*:

[What could go wrong technically?]

*Architectural Impact*:

[How does this risk affect the architecture?]

*Mitigation*:

* [Architectural mitigation 1 - e.g., "Implement ACL to isolate domain"]
* [Architectural mitigation 2 - e.g., "Circuit breaker pattern for resilience"]
* [Monitoring approach]

*Contingency*:

[If mitigation fails, what's the backup plan?]

=== Risk 2: [Risk Name]

// Repeat for each significant technical risk

*Common Technical Risks to Address*:

* External system dependencies (API stability, uptime, latency)
* Data migration complexity (volume, consistency, downtime)
* Integration complexity (multiple systems, transaction boundaries)
* Technology maturity (new tech, team expertise)
* Performance under load (scalability, throughput)
* Security vulnerabilities (authentication, authorization, data protection)

=== Technical Constraints

*Platform Constraints*:

* [Constraint 1 - e.g., "Must deploy to Azure (existing platform)"]
* [Constraint 2 - e.g., "Must use .NET Core (team expertise)"]

*Integration Constraints*:

* [Constraint 1 - e.g., "External system only supports batch file (no real-time API)"]
* [Constraint 2 - e.g., "Legacy system cannot be modified (read-only integration)"]

*Regulatory Constraints*:

* [Constraint 1 - e.g., "PCI DSS compliance required (no card data storage)"]
* [Constraint 2 - e.g., "GDPR right to erasure (data deletion capability required)"]

*Timeline Constraints*:

* [Constraint 1 - e.g., "Must complete Phase 1 before Q2 partner integration"]
* [Constraint 2 - e.g., "Cannot impact production during peak season"]

=== Dependencies

*Internal Dependencies*:

[cols="2,1,1,3"]
|===
|Dependency |Owner |Delivery Date |Impact if Delayed

|[Dependency 1]
|[Team/Person]
|[Date]
|[How it blocks this architecture]

|[Dependency 2]
|[Team/Person]
|[Date]
|[How it blocks this architecture]
|===

*External Dependencies*:

[cols="2,1,1,3"]
|===
|Dependency |Vendor |Delivery Date |Impact if Delayed

|[Dependency 1]
|[Vendor]
|[Date]
|[How it blocks this architecture]

|[Dependency 2]
|[Vendor]
|[Date]
|[How it blocks this architecture]
|===

== Non-Functional Requirements

// Single table format capturing all NFR categories for easier reference

[cols="1,1,2,4"]
|===
|ID |Category |Requirement |Target

|NFR-001
|Performance
|[Service] API latency
|< [value]ms p95 ([context - e.g., "customer profile queries"])

|NFR-002
|Performance
|[Service] API latency
|< [value]ms p95 ([context])

|NFR-003
|Performance
|[Operation] latency
|< [value] seconds p95 ([context - e.g., "mobile app"])

|NFR-004
|Performance
|Batch processing
|Complete by [time] ([context - e.g., "partner SLA"])

|NFR-005
|Performance
|Event publishing latency
|< [value] seconds (event appears in Event Bus)

|NFR-006
|Availability
|[Service] uptime
|[%] ([downtime allowed - e.g., "4.3 hours/month"])

|NFR-007
|Availability
|[Service] uptime
|[%] ([context])

|NFR-008
|Availability
|Event Bus availability
|[%] (guaranteed delivery with retry)

|NFR-009
|Security
|Encryption
|[Standard - e.g., "AES-256 at rest, TLS 1.3 in transit"]

|NFR-010
|Security
|Compliance
|[Standard - e.g., "PCI DSS - no PAN/CVV storage"]

|NFR-011
|Security
|Customer consent
|[Requirement - e.g., "OAuth requires explicit consent per privacy laws"]

|NFR-012
|Security
|Data residency
|[Requirement - e.g., "Customer data stored in Australia"]

|NFR-013
|Scalability
|[Service] capacity
|Support [number] active users (concurrent: [req/sec])

|NFR-014
|Scalability
|[Service] capacity
|Support [number] daily transactions (peak: [txn/sec])

|NFR-015
|Scalability
|Event Bus capacity
|Handle [number] events/day ([event types])

|NFR-016
|Reliability
|[Process] success rate
|[%]+ ([context - e.g., "batch file acknowledgement"])

|NFR-017
|Reliability
|[Calculation] accuracy
|[%] ([context - e.g., "matches external system calculation"])

|NFR-018
|Reliability
|Event delivery success
|[%] (Event Bus with retry)
|===

== Monitoring and Observability

=== Key Metrics

[cols="2,2,2"]
|===
|Service/Component |Metric |Unit/Description

|[BoundedContext]
|API latency
|p50, p95, p99

|[BoundedContext]
|API error rate
|4xx, 5xx

|[BoundedContext]
|[Domain-specific metric]
|[unit - e.g., "per day"]

|[BoundedContext]
|[Domain-specific metric]
|[unit]

|Event Bus
|Event publishing latency
|seconds

|Event Bus
|Event delivery success rate
|%

|Event Bus
|Dead letter queue depth
|event count
|===

=== Alerting Thresholds

[cols="1,3,2"]
|===
|Severity |Alert Condition |Notification Channel

|Critical
|[Service] API error rate > [%] for [duration]
|PagerDuty, on-call [role]

|Critical
|[Critical process] fails
|Immediate alert to [team]

|Warning
|[External system] API latency > [value] p95
|Immediate alert to [team]

|Warning
|Event Bus dead letter queue depth > [number] events
|Immediate alert to [team]
|===

=== Dashboards

[cols="2,4"]
|===
|Dashboard Name |Key Metrics Displayed

|[BoundedContext] Health
|API latency, error rate, throughput, [domain-specific metrics]

|[BoundedContext] Operations
|[Operation-specific metrics - e.g., "batch file status, external API health"]

|Event Bus Monitoring
|Event publishing latency, delivery success rate, DLQ depth
|===

=== Distributed Tracing

*Tracing Strategy*:

* Tool: [e.g., "OpenTelemetry with Application Insights backend"]
* What gets traced: [e.g., "All API calls, event publishing/consumption, external integrations"]
* Correlation ID strategy: [e.g., "Propagate correlation ID across all service boundaries"]

== Architecture Governance

=== Architecture Principles Applied

// Which OTR architecture principles does this initiative follow?

. *[Principle Name - e.g., "Bounded Context Independence"]*
** *Principle*: [Statement of principle]
** *Application*: [How this architecture applies the principle]

. *[Principle Name - e.g., "Event-Driven Integration"]*
** *Principle*: [Statement of principle]
** *Application*: [How this architecture applies the principle]

. *[Principle Name - e.g., "Database per Bounded Context"]*
** *Principle*: [Statement of principle]
** *Application*: [How this architecture applies the principle]

=== Compliance Checklist

// Does this architecture comply with platform standards?

* [ ] Bounded contexts follow DDD tactical patterns
* [ ] Integration patterns documented with Context Maps
* [ ] Technology choices align with platform standards
* [ ] Security requirements met (authentication, authorization, encryption)
* [ ] Monitoring and alerting strategy defined
* [ ] Performance requirements specified and measurable
* [ ] All ADRs documented with alternatives considered
* [ ] Migration strategy includes rollback plan
* [ ] Technical risks identified with mitigation
* [ ] Dependencies mapped with delivery dates

=== ARB Review Checklist

// What the ARB will evaluate

*Strategic Alignment*:

* [ ] Bounded contexts align with domain model
* [ ] Integration patterns appropriate for coupling level
* [ ] Technology choices align with platform strategy

*Technical Soundness*:

* [ ] Aggregates have clear invariants and transaction boundaries
* [ ] Data ownership clearly defined (no shared databases)
* [ ] Scalability and performance requirements addressed
* [ ] Security and compliance requirements met

*Risk Management*:

* [ ] Technical risks identified and mitigated
* [ ] Dependencies mapped and managed
* [ ] Rollback strategy defined

*Maintainability*:

* [ ] Architecture is evolvable (can change independently)
* [ ] Monitoring and observability strategy defined
* [ ] Documentation sufficient for implementation

[appendix]
== Context Map Diagram

// Include full Context Mapper CML diagram or reference

*CML Reference*: [Link to context-maps/[filename].cml]

*Diagram*:

----
[Include exported PNG from Context Mapper or inline CML]
----

[appendix]
== Glossary

// Define domain-specific terms for ARB members unfamiliar with domain

*[Domain Term]*: [Technical definition]

*[Domain Term]*: [Technical definition]

*[Domain Term]*: [Technical definition]

*[DDD Pattern Term]*: [Definition - e.g., "Anti-Corruption Layer (ACL): Translation layer that prevents external system models from leaking into domain"]

*[DDD Pattern Term]*: [Definition]

== Implementation Standards

=== Standards Compliance

[cols="2,4"]
|===
|Standard |Implementation

|OAuth 2.0
|[How implemented - e.g., "Authorization Code Flow with PKCE for mobile apps"]

|RESTful API Design
|[How implemented - e.g., "Resource-based endpoints, HTTP methods, status codes"]

|JSON Web Tokens (JWT)
|[How implemented - e.g., "Token format for secure claims transmission"]

|OpenAPI Specification
|[How implemented - e.g., "API documentation and contract definition"]

|DDD Strategic Patterns
|[How implemented - e.g., "Bounded contexts, context mapping, published language"]

|DDD Tactical Patterns
|[How implemented - e.g., "Aggregates with invariants, domain events, repositories"]

|[Framework Standard]
|[How implemented - e.g., "TOGAF Architecture Definition Document (ADD)"]
|===

'''

== Template Usage Notes

=== Before ARB Submission

. Remove all instructional text (like this section)
. Ensure all ADRs have alternatives documented
. Verify all bounded contexts have clear responsibilities
. Validate integration patterns are appropriate
. Confirm technology choices have rationale
. Check all technical risks have mitigation
. Link to business requirements document
. Include or reference Context Map diagram

=== ARB Presentation Focus

*Spend most time on*:

* Target state bounded context model (strategic design)
* Key architectural decisions (ADRs) with alternatives
* Integration patterns and rationale
* Technical risks and mitigation

*Spend less time on*:

* Current state (ARB likely familiar)
* Technology stack (unless controversial)
* Migration details (unless high risk)

=== Common ARB Questions to Prepare For

* Why these bounded context boundaries vs alternatives?
* Why this integration pattern vs alternatives?
* How does this align with platform architecture principles?
* What happens if [external dependency] fails?
* How do we roll back if this goes wrong?
* What's the blast radius if this bounded context fails?
* How does this support future requirements?
* What technical debt are we accepting and why?
